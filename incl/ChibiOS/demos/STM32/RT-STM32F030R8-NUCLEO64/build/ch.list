
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000200 	.word	0x20000200
 8000004:	08000191 	.word	0x08000191
 8000008:	08000cb1 	.word	0x08000cb1
 800000c:	08000193 	.word	0x08000193
 8000010:	08000193 	.word	0x08000193
 8000014:	08000193 	.word	0x08000193
 8000018:	08000193 	.word	0x08000193
 800001c:	08000193 	.word	0x08000193
 8000020:	08000193 	.word	0x08000193
 8000024:	08000193 	.word	0x08000193
 8000028:	08000193 	.word	0x08000193
 800002c:	08000193 	.word	0x08000193
 8000030:	08000193 	.word	0x08000193
 8000034:	08000193 	.word	0x08000193
 8000038:	08000193 	.word	0x08000193
 800003c:	08000193 	.word	0x08000193
 8000040:	08000193 	.word	0x08000193
 8000044:	08000193 	.word	0x08000193
 8000048:	08000193 	.word	0x08000193
 800004c:	08000193 	.word	0x08000193
 8000050:	08000193 	.word	0x08000193
 8000054:	08000193 	.word	0x08000193
 8000058:	08000193 	.word	0x08000193
 800005c:	08000193 	.word	0x08000193
 8000060:	08000193 	.word	0x08000193
 8000064:	08000193 	.word	0x08000193
 8000068:	08000193 	.word	0x08000193
 800006c:	08000193 	.word	0x08000193
 8000070:	08000193 	.word	0x08000193
 8000074:	08000193 	.word	0x08000193
 8000078:	08000193 	.word	0x08000193
 800007c:	08000193 	.word	0x08000193
 8000080:	08000ed1 	.word	0x08000ed1
 8000084:	08000193 	.word	0x08000193
 8000088:	08000193 	.word	0x08000193
 800008c:	08000193 	.word	0x08000193
 8000090:	08000193 	.word	0x08000193
 8000094:	08000193 	.word	0x08000193
 8000098:	08000193 	.word	0x08000193
 800009c:	08000193 	.word	0x08000193
 80000a0:	08000193 	.word	0x08000193
 80000a4:	08000193 	.word	0x08000193
 80000a8:	08000193 	.word	0x08000193
 80000ac:	08001131 	.word	0x08001131
 80000b0:	08000fa1 	.word	0x08000fa1
 80000b4:	08001141 	.word	0x08001141
 80000b8:	08000193 	.word	0x08000193
 80000bc:	08000193 	.word	0x08000193

Disassembly of section .text:

080000c0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80000c0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
                msr     MSP, r0
 80000c4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
                msr     PSP, r0
 80000ca:	f380 8809 	msr	PSP, r0

                /* CPU mode initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 80000ce:	2002      	movs	r0, #2
                msr     CONTROL, r0
 80000d0:	f380 8814 	msr	CONTROL, r0
                isb
 80000d4:	f3bf 8f6f 	isb	sy
                str     r0, [r1]
#endif

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80000d8:	f001 f87a 	bl	80011d0 <__core_init>
#endif

                /* Early initialization..*/
                bl      __early_init
 80000dc:	f000 fe38 	bl	8000d50 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
msloop:
                cmp     r1, r2
 80000e6:	4291      	cmp	r1, r2
                bge     endmsloop
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
                str     r0, [r1]
 80000ea:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000ec:	3104      	adds	r1, #4
                b       msloop
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
psloop:
                cmp     r1, r2
 80000f4:	4291      	cmp	r1, r2
                bge     endpsloop
 80000f6:	da02      	bge.n	80000fe <endpsloop>
                str     r0, [r1]
 80000f8:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000fa:	3104      	adds	r1, #4
                b       psloop
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
                ldr     r2, =__data_base__
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
                ldr     r3, =__data_end__
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
dloop:
                cmp     r2, r3
 8000104:	429a      	cmp	r2, r3
                bge     enddloop
 8000106:	da04      	bge.n	8000112 <enddloop>
                ldr     r0, [r1]
 8000108:	6808      	ldr	r0, [r1, #0]
                str     r0, [r2]
 800010a:	6010      	str	r0, [r2, #0]
                adds    r1, #4
 800010c:	3104      	adds	r1, #4
                adds    r2, #4
 800010e:	3204      	adds	r2, #4
                b       dloop
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000112:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
                ldr     r2, =__bss_end__
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
bloop:
                cmp     r1, r2
 8000118:	4291      	cmp	r1, r2
                bge     endbloop
 800011a:	da02      	bge.n	8000122 <endbloop>
                str     r0, [r1]
 800011c:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 800011e:	3104      	adds	r1, #4
                b       bloop
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
endbloop:
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000122:	f001 f815 	bl	8001150 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000126:	f001 f84b 	bl	80011c0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end__
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
initloop:
                cmp     r4, r5
 800012e:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000130:	da03      	bge.n	800013a <endinitloop>
                ldr     r1, [r4]
 8000132:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000134:	4788      	blx	r1
                adds    r4, #4
 8000136:	3404      	adds	r4, #4
                b       initloop
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800013a:	f000 fbd9 	bl	80008f0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end__
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
finiloop:
                cmp     r4, r5
 8000142:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000144:	da03      	bge.n	800014e <endfiniloop>
                ldr     r1, [r4]
 8000146:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000148:	4788      	blx	r1
                adds    r4, #4
 800014a:	3404      	adds	r4, #4
                b       finiloop
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
                bx      r1
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 8000154:	20000200 	.word	0x20000200
                ldr     r0, =__process_stack_end__
 8000158:	20000400 	.word	0x20000400
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800015c:	55555555 	.word	0x55555555
                ldr     r1, =__main_stack_base__
 8000160:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000164:	20000200 	.word	0x20000200
                ldr     r1, =__textdata_base__
 8000168:	080012bc 	.word	0x080012bc
                ldr     r2, =__data_base__
 800016c:	20000400 	.word	0x20000400
                ldr     r3, =__data_end__
 8000170:	20000400 	.word	0x20000400
                ldr     r1, =__bss_base__
 8000174:	20000400 	.word	0x20000400
                ldr     r2, =__bss_end__
 8000178:	2000063c 	.word	0x2000063c
                ldr     r4, =__init_array_base__
 800017c:	080000c0 	.word	0x080000c0
                ldr     r5, =__init_array_end__
 8000180:	080000c0 	.word	0x080000c0
                ldr     r4, =__fini_array_base__
 8000184:	080000c0 	.word	0x080000c0
                ldr     r5, =__fini_array_end__
 8000188:	080000c0 	.word	0x080000c0
                ldr     r1, =__default_exit
 800018c:	080011b1 	.word	0x080011b1

08000190 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000190:	e796      	b.n	80000c0 <_crt0_entry>

08000192 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000192:	f000 f800 	bl	8000196 <_unhandled_exception>

08000196 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000196:	e7fe      	b.n	8000196 <_unhandled_exception>

08000198 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, lr}
 8000198:	b5f0      	push	{r4, r5, r6, r7, lr}
                mov     r4, r8
 800019a:	4644      	mov	r4, r8
                mov     r5, r9
 800019c:	464d      	mov	r5, r9
                mov     r6, r10
 800019e:	4656      	mov	r6, sl
                mov     r7, r11
 80001a0:	465f      	mov	r7, fp
                push    {r4, r5, r6, r7}
 80001a2:	b4f0      	push	{r4, r5, r6, r7}
                
                mov     r3, sp
 80001a4:	466b      	mov	r3, sp
                str     r3, [r1, #CONTEXT_OFFSET]
 80001a6:	60cb      	str	r3, [r1, #12]
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80001a8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80001aa:	469d      	mov	sp, r3
                
                pop     {r4, r5, r6, r7}
 80001ac:	bcf0      	pop	{r4, r5, r6, r7}
                mov     r8, r4
 80001ae:	46a0      	mov	r8, r4
                mov     r9, r5
 80001b0:	46a9      	mov	r9, r5
                mov     r10, r6
 80001b2:	46b2      	mov	sl, r6
                mov     r11, r7
 80001b4:	46bb      	mov	fp, r7
                pop     {r4, r5, r6, r7, pc}
 80001b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b8 <_port_thread_start>:
                bl      _dbg_check_unlock
#endif
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
#endif
                cpsie   i
 80001b8:	b662      	cpsie	i
                mov     r0, r5
 80001ba:	1c28      	adds	r0, r5, #0
                blx     r4
 80001bc:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80001be:	2000      	movs	r0, #0
                bl      chThdExit
 80001c0:	f000 fd7e 	bl	8000cc0 <chThdExit>

080001c4 <_zombies>:
_zombies:       b       _zombies
 80001c4:	e7fe      	b.n	80001c4 <_zombies>

080001c6 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80001c6:	f000 fda3 	bl	8000d10 <chSchDoReschedule>

080001ca <_port_exit_from_isr>:
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
#endif
                .globl  _port_exit_from_isr
_port_exit_from_isr:
                ldr     r2, .L2
 80001ca:	4a02      	ldr	r2, [pc, #8]	; (80001d4 <_port_exit_from_isr+0xa>)
                ldr     r3, .L3
 80001cc:	4b02      	ldr	r3, [pc, #8]	; (80001d8 <_port_exit_from_isr+0xe>)
                str     r3, [r2, #0]
 80001ce:	6013      	str	r3, [r2, #0]
#if CORTEX_ALTERNATE_SWITCH
                cpsie   i
#endif
.L1:            b       .L1
 80001d0:	e7fe      	b.n	80001d0 <_port_exit_from_isr+0x6>
 80001d2:	46c0      	nop			; (mov r8, r8)
 80001d4:	e000ed04 	.word	0xe000ed04
 80001d8:	80000000 	.word	0x80000000

080001dc <memcpy>:
 80001dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001de:	46c6      	mov	lr, r8
 80001e0:	b500      	push	{lr}
 80001e2:	2a0f      	cmp	r2, #15
 80001e4:	d943      	bls.n	800026e <memcpy+0x92>
 80001e6:	000b      	movs	r3, r1
 80001e8:	2603      	movs	r6, #3
 80001ea:	4303      	orrs	r3, r0
 80001ec:	401e      	ands	r6, r3
 80001ee:	000c      	movs	r4, r1
 80001f0:	0003      	movs	r3, r0
 80001f2:	2e00      	cmp	r6, #0
 80001f4:	d140      	bne.n	8000278 <memcpy+0x9c>
 80001f6:	0015      	movs	r5, r2
 80001f8:	3d10      	subs	r5, #16
 80001fa:	092d      	lsrs	r5, r5, #4
 80001fc:	46ac      	mov	ip, r5
 80001fe:	012d      	lsls	r5, r5, #4
 8000200:	46a8      	mov	r8, r5
 8000202:	4480      	add	r8, r0
 8000204:	e000      	b.n	8000208 <memcpy+0x2c>
 8000206:	003b      	movs	r3, r7
 8000208:	6867      	ldr	r7, [r4, #4]
 800020a:	6825      	ldr	r5, [r4, #0]
 800020c:	605f      	str	r7, [r3, #4]
 800020e:	68e7      	ldr	r7, [r4, #12]
 8000210:	601d      	str	r5, [r3, #0]
 8000212:	60df      	str	r7, [r3, #12]
 8000214:	001f      	movs	r7, r3
 8000216:	68a5      	ldr	r5, [r4, #8]
 8000218:	3710      	adds	r7, #16
 800021a:	609d      	str	r5, [r3, #8]
 800021c:	3410      	adds	r4, #16
 800021e:	4543      	cmp	r3, r8
 8000220:	d1f1      	bne.n	8000206 <memcpy+0x2a>
 8000222:	4665      	mov	r5, ip
 8000224:	230f      	movs	r3, #15
 8000226:	240c      	movs	r4, #12
 8000228:	3501      	adds	r5, #1
 800022a:	012d      	lsls	r5, r5, #4
 800022c:	1949      	adds	r1, r1, r5
 800022e:	4013      	ands	r3, r2
 8000230:	1945      	adds	r5, r0, r5
 8000232:	4214      	tst	r4, r2
 8000234:	d023      	beq.n	800027e <memcpy+0xa2>
 8000236:	598c      	ldr	r4, [r1, r6]
 8000238:	51ac      	str	r4, [r5, r6]
 800023a:	3604      	adds	r6, #4
 800023c:	1b9c      	subs	r4, r3, r6
 800023e:	2c03      	cmp	r4, #3
 8000240:	d8f9      	bhi.n	8000236 <memcpy+0x5a>
 8000242:	2403      	movs	r4, #3
 8000244:	3b04      	subs	r3, #4
 8000246:	089b      	lsrs	r3, r3, #2
 8000248:	3301      	adds	r3, #1
 800024a:	009b      	lsls	r3, r3, #2
 800024c:	4022      	ands	r2, r4
 800024e:	18ed      	adds	r5, r5, r3
 8000250:	18c9      	adds	r1, r1, r3
 8000252:	1e56      	subs	r6, r2, #1
 8000254:	2a00      	cmp	r2, #0
 8000256:	d007      	beq.n	8000268 <memcpy+0x8c>
 8000258:	2300      	movs	r3, #0
 800025a:	e000      	b.n	800025e <memcpy+0x82>
 800025c:	0023      	movs	r3, r4
 800025e:	5cca      	ldrb	r2, [r1, r3]
 8000260:	1c5c      	adds	r4, r3, #1
 8000262:	54ea      	strb	r2, [r5, r3]
 8000264:	429e      	cmp	r6, r3
 8000266:	d1f9      	bne.n	800025c <memcpy+0x80>
 8000268:	bc04      	pop	{r2}
 800026a:	4690      	mov	r8, r2
 800026c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800026e:	0005      	movs	r5, r0
 8000270:	1e56      	subs	r6, r2, #1
 8000272:	2a00      	cmp	r2, #0
 8000274:	d1f0      	bne.n	8000258 <memcpy+0x7c>
 8000276:	e7f7      	b.n	8000268 <memcpy+0x8c>
 8000278:	1e56      	subs	r6, r2, #1
 800027a:	0005      	movs	r5, r0
 800027c:	e7ec      	b.n	8000258 <memcpy+0x7c>
 800027e:	001a      	movs	r2, r3
 8000280:	e7f6      	b.n	8000270 <memcpy+0x94>
 8000282:	46c0      	nop			; (mov r8, r8)
	...

08000290 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8000290:	b530      	push	{r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000292:	b672      	cpsid	i
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000294:	4c07      	ldr	r4, [pc, #28]	; (80002b4 <chCoreAllocFromTop+0x24>)
 8000296:	6865      	ldr	r5, [r4, #4]
 8000298:	1a2b      	subs	r3, r5, r0
 800029a:	4248      	negs	r0, r1
 800029c:	4018      	ands	r0, r3
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 800029e:	6823      	ldr	r3, [r4, #0]
  prev = p - offset;
 80002a0:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80002a2:	429a      	cmp	r2, r3
 80002a4:	d304      	bcc.n	80002b0 <chCoreAllocFromTop+0x20>
 80002a6:	4295      	cmp	r5, r2
 80002a8:	d302      	bcc.n	80002b0 <chCoreAllocFromTop+0x20>
  ch_memcore.topmem = prev;
 80002aa:	6062      	str	r2, [r4, #4]
  __ASM volatile ("cpsie i" : : : "memory");
 80002ac:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 80002ae:	bd30      	pop	{r4, r5, pc}
    return NULL;
 80002b0:	2000      	movs	r0, #0
 80002b2:	e7fb      	b.n	80002ac <chCoreAllocFromTop+0x1c>
 80002b4:	200005f8 	.word	0x200005f8
	...

080002c0 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 80002c0:	21c0      	movs	r1, #192	; 0xc0
 80002c2:	4a02      	ldr	r2, [pc, #8]	; (80002cc <notify2+0xc>)
 80002c4:	6813      	ldr	r3, [r2, #0]
 80002c6:	430b      	orrs	r3, r1
 80002c8:	6013      	str	r3, [r2, #0]
}
 80002ca:	4770      	bx	lr
 80002cc:	40004400 	.word	0x40004400

080002d0 <_port_irq_epilogue.part.0>:
  __ASM volatile ("cpsid i" : : : "memory");
 80002d0:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80002d2:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ectxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ectxp--;
 80002d6:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80002d8:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ectxp);

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 80002dc:	2280      	movs	r2, #128	; 0x80
 80002de:	0452      	lsls	r2, r2, #17
 80002e0:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80002e2:	4a06      	ldr	r2, [pc, #24]	; (80002fc <_port_irq_epilogue.part.0+0x2c>)
 80002e4:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 80002e6:	6992      	ldr	r2, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80002e8:	6889      	ldr	r1, [r1, #8]
 80002ea:	6892      	ldr	r2, [r2, #8]
 80002ec:	4291      	cmp	r1, r2
 80002ee:	d902      	bls.n	80002f6 <_port_irq_epilogue.part.0+0x26>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)_port_switch_from_isr;
 80002f0:	4a03      	ldr	r2, [pc, #12]	; (8000300 <_port_irq_epilogue.part.0+0x30>)
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 80002f2:	619a      	str	r2, [r3, #24]
 80002f4:	4770      	bx	lr
      ectxp->pc = (uint32_t)_port_exit_from_isr;
 80002f6:	4a03      	ldr	r2, [pc, #12]	; (8000304 <_port_irq_epilogue.part.0+0x34>)
 80002f8:	e7fb      	b.n	80002f2 <_port_irq_epilogue.part.0+0x22>
 80002fa:	46c0      	nop			; (mov r8, r8)
 80002fc:	20000460 	.word	0x20000460
 8000300:	080001c7 	.word	0x080001c7
 8000304:	080001ca 	.word	0x080001ca
	...

08000310 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000310:	4a07      	ldr	r2, [pc, #28]	; (8000330 <chCoreAllocAlignedI+0x20>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8000312:	b510      	push	{r4, lr}
 8000314:	6854      	ldr	r4, [r2, #4]
 8000316:	1a23      	subs	r3, r4, r0
 8000318:	4248      	negs	r0, r1
 800031a:	4018      	ands	r0, r3
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 800031c:	6813      	ldr	r3, [r2, #0]
 800031e:	4298      	cmp	r0, r3
 8000320:	d303      	bcc.n	800032a <chCoreAllocAlignedI+0x1a>
 8000322:	4284      	cmp	r4, r0
 8000324:	d301      	bcc.n	800032a <chCoreAllocAlignedI+0x1a>
  ch_memcore.topmem = prev;
 8000326:	6050      	str	r0, [r2, #4]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8000328:	bd10      	pop	{r4, pc}
    return NULL;
 800032a:	2000      	movs	r0, #0
 800032c:	e7fc      	b.n	8000328 <chCoreAllocAlignedI+0x18>
 800032e:	46c0      	nop			; (mov r8, r8)
 8000330:	200005f8 	.word	0x200005f8
	...

08000340 <wakeup>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000340:	b672      	cpsid	i
  switch (tp->state) {
 8000342:	2320      	movs	r3, #32
 8000344:	5cc3      	ldrb	r3, [r0, r3]
 8000346:	2b07      	cmp	r3, #7
 8000348:	d80b      	bhi.n	8000362 <wakeup+0x22>
 800034a:	4a11      	ldr	r2, [pc, #68]	; (8000390 <wakeup+0x50>)
 800034c:	009b      	lsls	r3, r3, #2
 800034e:	58d3      	ldr	r3, [r2, r3]
 8000350:	469f      	mov	pc, r3
    chSemFastSignalI(tp->u.wtsemp);
 8000352:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8000354:	6893      	ldr	r3, [r2, #8]
 8000356:	3301      	adds	r3, #1
 8000358:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800035a:	6842      	ldr	r2, [r0, #4]
 800035c:	6803      	ldr	r3, [r0, #0]
 800035e:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000360:	605a      	str	r2, [r3, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 8000362:	2301      	movs	r3, #1
  tp->state = CH_STATE_READY;
 8000364:	2200      	movs	r2, #0
  tp->u.rdymsg = MSG_TIMEOUT;
 8000366:	425b      	negs	r3, r3
 8000368:	6243      	str	r3, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 800036a:	3321      	adds	r3, #33	; 0x21
 800036c:	54c2      	strb	r2, [r0, r3]
  } while (cp->prio >= tp->prio);
 800036e:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000370:	4b08      	ldr	r3, [pc, #32]	; (8000394 <wakeup+0x54>)
    cp = cp->queue.next;
 8000372:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000374:	6899      	ldr	r1, [r3, #8]
 8000376:	4291      	cmp	r1, r2
 8000378:	d2fb      	bcs.n	8000372 <wakeup+0x32>
  tp->queue.prev             = cp->queue.prev;
 800037a:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 800037c:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 800037e:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000380:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000382:	6058      	str	r0, [r3, #4]
  __ASM volatile ("cpsie i" : : : "memory");
 8000384:	b662      	cpsie	i
}
 8000386:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 8000388:	2200      	movs	r2, #0
 800038a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800038c:	601a      	str	r2, [r3, #0]
    break;
 800038e:	e7e8      	b.n	8000362 <wakeup+0x22>
 8000390:	080011d4 	.word	0x080011d4
 8000394:	20000460 	.word	0x20000460
	...

080003a0 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 80003a0:	2320      	movs	r3, #32
 80003a2:	2200      	movs	r2, #0
 80003a4:	54c2      	strb	r2, [r0, r3]
  } while (cp->prio >= tp->prio);
 80003a6:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 80003a8:	4b05      	ldr	r3, [pc, #20]	; (80003c0 <chSchReadyI+0x20>)
    cp = cp->queue.next;
 80003aa:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80003ac:	6899      	ldr	r1, [r3, #8]
 80003ae:	4291      	cmp	r1, r2
 80003b0:	d2fb      	bcs.n	80003aa <chSchReadyI+0xa>
  tp->queue.prev             = cp->queue.prev;
 80003b2:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 80003b4:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 80003b6:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 80003b8:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80003ba:	6058      	str	r0, [r3, #4]
}
 80003bc:	4770      	bx	lr
 80003be:	46c0      	nop			; (mov r8, r8)
 80003c0:	20000460 	.word	0x20000460
	...

080003d0 <chEvtBroadcastFlagsI.constprop.0>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80003d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80003d2:	46c6      	mov	lr, r8
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80003d4:	4e18      	ldr	r6, [pc, #96]	; (8000438 <chEvtBroadcastFlagsI.constprop.0+0x68>)
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80003d6:	0005      	movs	r5, r0
  elp = esp->next;
 80003d8:	6874      	ldr	r4, [r6, #4]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80003da:	3604      	adds	r6, #4
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80003dc:	b500      	push	{lr}
  while (elp != (event_listener_t *)esp) {
 80003de:	42b4      	cmp	r4, r6
 80003e0:	d022      	beq.n	8000428 <chEvtBroadcastFlagsI.constprop.0+0x58>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80003e2:	2300      	movs	r3, #0
  if (((tp->state == CH_STATE_WTOREVT) &&
 80003e4:	2720      	movs	r7, #32
    tp->u.rdymsg = MSG_OK;
 80003e6:	4698      	mov	r8, r3
 80003e8:	e004      	b.n	80003f4 <chEvtBroadcastFlagsI.constprop.0+0x24>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80003ea:	2a0b      	cmp	r2, #11
 80003ec:	d01f      	beq.n	800042e <chEvtBroadcastFlagsI.constprop.0+0x5e>
    elp = elp->next;
 80003ee:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80003f0:	42b4      	cmp	r4, r6
 80003f2:	d019      	beq.n	8000428 <chEvtBroadcastFlagsI.constprop.0+0x58>
    elp->flags |= flags;
 80003f4:	68e3      	ldr	r3, [r4, #12]
 80003f6:	432b      	orrs	r3, r5
 80003f8:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80003fa:	2d00      	cmp	r5, #0
 80003fc:	d002      	beq.n	8000404 <chEvtBroadcastFlagsI.constprop.0+0x34>
 80003fe:	6923      	ldr	r3, [r4, #16]
 8000400:	422b      	tst	r3, r5
 8000402:	d0f4      	beq.n	80003ee <chEvtBroadcastFlagsI.constprop.0+0x1e>
      chEvtSignalI(elp->listener, elp->events);
 8000404:	6860      	ldr	r0, [r4, #4]
  tp->epending |= events;
 8000406:	68a3      	ldr	r3, [r4, #8]
 8000408:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800040a:	4313      	orrs	r3, r2
 800040c:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 800040e:	5dc2      	ldrb	r2, [r0, r7]
 8000410:	2a0a      	cmp	r2, #10
 8000412:	d1ea      	bne.n	80003ea <chEvtBroadcastFlagsI.constprop.0+0x1a>
 8000414:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000416:	421a      	tst	r2, r3
 8000418:	d0e9      	beq.n	80003ee <chEvtBroadcastFlagsI.constprop.0+0x1e>
    tp->u.rdymsg = MSG_OK;
 800041a:	4643      	mov	r3, r8
 800041c:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 800041e:	f7ff ffbf 	bl	80003a0 <chSchReadyI>
    elp = elp->next;
 8000422:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8000424:	42b4      	cmp	r4, r6
 8000426:	d1e5      	bne.n	80003f4 <chEvtBroadcastFlagsI.constprop.0+0x24>
}
 8000428:	bc04      	pop	{r2}
 800042a:	4690      	mov	r8, r2
 800042c:	bdf0      	pop	{r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 800042e:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000430:	4013      	ands	r3, r2
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000432:	429a      	cmp	r2, r3
 8000434:	d1db      	bne.n	80003ee <chEvtBroadcastFlagsI.constprop.0+0x1e>
 8000436:	e7f0      	b.n	800041a <chEvtBroadcastFlagsI.constprop.0+0x4a>
 8000438:	20000400 	.word	0x20000400
 800043c:	00000000 	.word	0x00000000

08000440 <_idle_thread>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000440:	e7fe      	b.n	8000440 <_idle_thread>
 8000442:	46c0      	nop			; (mov r8, r8)
	...

08000450 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000450:	4a0d      	ldr	r2, [pc, #52]	; (8000488 <nvicEnableVector+0x38>)
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000452:	b570      	push	{r4, r5, r6, lr}
 8000454:	4694      	mov	ip, r2
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000456:	2203      	movs	r2, #3
 8000458:	25ff      	movs	r5, #255	; 0xff
 800045a:	26c0      	movs	r6, #192	; 0xc0
 800045c:	4002      	ands	r2, r0
 800045e:	00d2      	lsls	r2, r2, #3
 8000460:	4095      	lsls	r5, r2
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 8000462:	0189      	lsls	r1, r1, #6
 8000464:	4091      	lsls	r1, r2
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000466:	0883      	lsrs	r3, r0, #2
 8000468:	009b      	lsls	r3, r3, #2
 800046a:	4463      	add	r3, ip
 800046c:	00b6      	lsls	r6, r6, #2
 800046e:	599c      	ldr	r4, [r3, r6]
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000470:	4662      	mov	r2, ip
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000472:	43ac      	bics	r4, r5
 8000474:	430c      	orrs	r4, r1
 8000476:	519c      	str	r4, [r3, r6]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000478:	2301      	movs	r3, #1
 800047a:	21c0      	movs	r1, #192	; 0xc0
 800047c:	4083      	lsls	r3, r0
 800047e:	0049      	lsls	r1, r1, #1
 8000480:	5053      	str	r3, [r2, r1]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000482:	6013      	str	r3, [r2, #0]
}
 8000484:	bd70      	pop	{r4, r5, r6, pc}
 8000486:	46c0      	nop			; (mov r8, r8)
 8000488:	e000e100 	.word	0xe000e100
 800048c:	00000000 	.word	0x00000000

08000490 <_ctl>:
#else
    break;
#endif
  }
  return MSG_OK;
}
 8000490:	2000      	movs	r0, #0
 8000492:	4770      	bx	lr
	...

080004a0 <chSchGoSleepS>:
  otp->state = newstate;
 80004a0:	2220      	movs	r2, #32
  thread_t *otp = currp;
 80004a2:	4b07      	ldr	r3, [pc, #28]	; (80004c0 <chSchGoSleepS+0x20>)
void chSchGoSleepS(tstate_t newstate) {
 80004a4:	b510      	push	{r4, lr}
  thread_t *otp = currp;
 80004a6:	6999      	ldr	r1, [r3, #24]
  otp->state = newstate;
 80004a8:	5488      	strb	r0, [r1, r2]
  thread_t *tp = tqp->next;
 80004aa:	6818      	ldr	r0, [r3, #0]
  tqp->next             = tp->queue.next;
 80004ac:	6804      	ldr	r4, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80004ae:	6063      	str	r3, [r4, #4]
  tqp->next             = tp->queue.next;
 80004b0:	601c      	str	r4, [r3, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
 80004b2:	6198      	str	r0, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 80004b4:	2301      	movs	r3, #1
 80004b6:	5483      	strb	r3, [r0, r2]
  chSysSwitch(currp, otp);
 80004b8:	f7ff fe6e 	bl	8000198 <_port_switch>
}
 80004bc:	bd10      	pop	{r4, pc}
 80004be:	46c0      	nop			; (mov r8, r8)
 80004c0:	20000460 	.word	0x20000460
	...

080004d0 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80004d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80004d2:	46c6      	mov	lr, r8
 80004d4:	b500      	push	{lr}
 80004d6:	b086      	sub	sp, #24
  if (TIME_INFINITE != timeout) {
 80004d8:	1c4b      	adds	r3, r1, #1
 80004da:	d052      	beq.n	8000582 <chSchGoSleepTimeoutS+0xb2>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 80004dc:	4c4b      	ldr	r4, [pc, #300]	; (800060c <chSchGoSleepTimeoutS+0x13c>)
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 80004de:	ad01      	add	r5, sp, #4
 80004e0:	69a3      	ldr	r3, [r4, #24]
 80004e2:	612b      	str	r3, [r5, #16]
  vtp->func = vtfunc;
 80004e4:	4b4a      	ldr	r3, [pc, #296]	; (8000610 <chSchGoSleepTimeoutS+0x140>)
 80004e6:	60eb      	str	r3, [r5, #12]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80004e8:	4b4a      	ldr	r3, [pc, #296]	; (8000614 <chSchGoSleepTimeoutS+0x144>)
 80004ea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80004ec:	b292      	uxth	r2, r2
 80004ee:	2902      	cmp	r1, #2
 80004f0:	d338      	bcc.n	8000564 <chSchGoSleepTimeoutS+0x94>
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80004f2:	0026      	movs	r6, r4
 80004f4:	69e3      	ldr	r3, [r4, #28]
 80004f6:	361c      	adds	r6, #28
 80004f8:	42b3      	cmp	r3, r6
 80004fa:	d067      	beq.n	80005cc <chSchGoSleepTimeoutS+0xfc>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80004fc:	8d26      	ldrh	r6, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80004fe:	1b92      	subs	r2, r2, r6
 8000500:	b292      	uxth	r2, r2
 8000502:	1889      	adds	r1, r1, r2

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8000504:	428a      	cmp	r2, r1
 8000506:	d92f      	bls.n	8000568 <chSchGoSleepTimeoutS+0x98>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8000508:	689a      	ldr	r2, [r3, #8]
      p = p->next;
 800050a:	681b      	ldr	r3, [r3, #0]
      delta -= p->delta;
 800050c:	1a89      	subs	r1, r1, r2
 800050e:	689a      	ldr	r2, [r3, #8]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000510:	428a      	cmp	r2, r1
 8000512:	d3fa      	bcc.n	800050a <chSchGoSleepTimeoutS+0x3a>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000514:	685a      	ldr	r2, [r3, #4]
  vtp->next = p;
 8000516:	9301      	str	r3, [sp, #4]
  vtp->prev = vtp->next->prev;
 8000518:	606a      	str	r2, [r5, #4]
  vtp->prev->next = vtp;
 800051a:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 800051c:	605d      	str	r5, [r3, #4]
  vtp->delta = delta;
 800051e:	60a9      	str	r1, [r5, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8000520:	689a      	ldr	r2, [r3, #8]
 8000522:	1a51      	subs	r1, r2, r1
 8000524:	6099      	str	r1, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8000526:	2301      	movs	r3, #1
 8000528:	425b      	negs	r3, r3
 800052a:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 800052c:	f7ff ffb8 	bl	80004a0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000530:	9b04      	ldr	r3, [sp, #16]
 8000532:	2b00      	cmp	r3, #0
 8000534:	d010      	beq.n	8000558 <chSchGoSleepTimeoutS+0x88>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000536:	69e3      	ldr	r3, [r4, #28]
 8000538:	42ab      	cmp	r3, r5
 800053a:	d026      	beq.n	800058a <chSchGoSleepTimeoutS+0xba>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800053c:	686a      	ldr	r2, [r5, #4]
 800053e:	9b01      	ldr	r3, [sp, #4]
 8000540:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8000542:	9b01      	ldr	r3, [sp, #4]
 8000544:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000546:	0022      	movs	r2, r4
 8000548:	321c      	adds	r2, #28
 800054a:	4293      	cmp	r3, r2
 800054c:	d004      	beq.n	8000558 <chSchGoSleepTimeoutS+0x88>
      vtp->next->delta += vtp->delta;
 800054e:	6899      	ldr	r1, [r3, #8]
 8000550:	68aa      	ldr	r2, [r5, #8]
 8000552:	468c      	mov	ip, r1
 8000554:	4462      	add	r2, ip
 8000556:	609a      	str	r2, [r3, #8]
  return currp->u.rdymsg;
 8000558:	69a3      	ldr	r3, [r4, #24]
 800055a:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 800055c:	b006      	add	sp, #24
 800055e:	bc04      	pop	{r2}
 8000560:	4690      	mov	r8, r2
 8000562:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000564:	2102      	movs	r1, #2
 8000566:	e7c4      	b.n	80004f2 <chSchGoSleepTimeoutS+0x22>
    else if (delta < p->delta) {
 8000568:	689a      	ldr	r2, [r3, #8]
 800056a:	4291      	cmp	r1, r2
 800056c:	d2d0      	bcs.n	8000510 <chSchGoSleepTimeoutS+0x40>
  return systime + (systime_t)interval;
 800056e:	2780      	movs	r7, #128	; 0x80
 8000570:	4688      	mov	r8, r1
 8000572:	027f      	lsls	r7, r7, #9
 8000574:	42b9      	cmp	r1, r7
 8000576:	d23c      	bcs.n	80005f2 <chSchGoSleepTimeoutS+0x122>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000578:	4f26      	ldr	r7, [pc, #152]	; (8000614 <chSchGoSleepTimeoutS+0x144>)
 800057a:	4446      	add	r6, r8
 800057c:	b2b6      	uxth	r6, r6
 800057e:	637e      	str	r6, [r7, #52]	; 0x34
 8000580:	e7c6      	b.n	8000510 <chSchGoSleepTimeoutS+0x40>
    chSchGoSleepS(newstate);
 8000582:	f7ff ff8d 	bl	80004a0 <chSchGoSleepS>
 8000586:	4c21      	ldr	r4, [pc, #132]	; (800060c <chSchGoSleepTimeoutS+0x13c>)
 8000588:	e7e6      	b.n	8000558 <chSchGoSleepTimeoutS+0x88>
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800058a:	0023      	movs	r3, r4
  vtp->func = NULL;
 800058c:	2100      	movs	r1, #0
  ch.vtlist.next = vtp->next;
 800058e:	682a      	ldr	r2, [r5, #0]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000590:	331c      	adds	r3, #28
  ch.vtlist.next = vtp->next;
 8000592:	61e2      	str	r2, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000594:	6053      	str	r3, [r2, #4]
  vtp->func = NULL;
 8000596:	60e9      	str	r1, [r5, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000598:	429a      	cmp	r2, r3
 800059a:	d033      	beq.n	8000604 <chSchGoSleepTimeoutS+0x134>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800059c:	6891      	ldr	r1, [r2, #8]
 800059e:	68ab      	ldr	r3, [r5, #8]
 80005a0:	468c      	mov	ip, r1
 80005a2:	4463      	add	r3, ip
 80005a4:	6093      	str	r3, [r2, #8]
  return (systime_t)STM32_ST_TIM->CNT;
 80005a6:	4a1b      	ldr	r2, [pc, #108]	; (8000614 <chSchGoSleepTimeoutS+0x144>)
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 80005a8:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 80005aa:	6a52      	ldr	r2, [r2, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80005ac:	1a52      	subs	r2, r2, r1
 80005ae:	b292      	uxth	r2, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 80005b0:	4293      	cmp	r3, r2
 80005b2:	d9d1      	bls.n	8000558 <chSchGoSleepTimeoutS+0x88>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 80005b4:	1a98      	subs	r0, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 80005b6:	2801      	cmp	r0, #1
 80005b8:	d922      	bls.n	8000600 <chSchGoSleepTimeoutS+0x130>
  }
  else {
    delta = nowdelta + delta;
#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
    /* The delta could be too large for the physical timer to handle.*/
    if (delta > (sysinterval_t)TIME_MAX_SYSTIME) {
 80005ba:	2280      	movs	r2, #128	; 0x80
 80005bc:	0252      	lsls	r2, r2, #9
 80005be:	4293      	cmp	r3, r2
 80005c0:	d21c      	bcs.n	80005fc <chSchGoSleepTimeoutS+0x12c>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80005c2:	4a14      	ldr	r2, [pc, #80]	; (8000614 <chSchGoSleepTimeoutS+0x144>)
  return systime + (systime_t)interval;
 80005c4:	18cb      	adds	r3, r1, r3
 80005c6:	b29b      	uxth	r3, r3
 80005c8:	6353      	str	r3, [r2, #52]	; 0x34
 80005ca:	e7c5      	b.n	8000558 <chSchGoSleepTimeoutS+0x88>
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80005cc:	9301      	str	r3, [sp, #4]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80005ce:	606b      	str	r3, [r5, #4]
 80005d0:	2380      	movs	r3, #128	; 0x80
      ch.vtlist.lasttime = now;
 80005d2:	8522      	strh	r2, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 80005d4:	61e5      	str	r5, [r4, #28]
      ch.vtlist.prev = vtp;
 80005d6:	6225      	str	r5, [r4, #32]
      vtp->delta = delay;
 80005d8:	60a9      	str	r1, [r5, #8]
 80005da:	025b      	lsls	r3, r3, #9
 80005dc:	4299      	cmp	r1, r3
 80005de:	d20b      	bcs.n	80005f8 <chSchGoSleepTimeoutS+0x128>
 80005e0:	1851      	adds	r1, r2, r1
  STM32_ST_TIM->SR     = 0;
 80005e2:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80005e4:	4b0b      	ldr	r3, [pc, #44]	; (8000614 <chSchGoSleepTimeoutS+0x144>)
 80005e6:	b289      	uxth	r1, r1
 80005e8:	6359      	str	r1, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80005ea:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80005ec:	3202      	adds	r2, #2
 80005ee:	60da      	str	r2, [r3, #12]
 80005f0:	e79c      	b.n	800052c <chSchGoSleepTimeoutS+0x5c>
 80005f2:	4f09      	ldr	r7, [pc, #36]	; (8000618 <chSchGoSleepTimeoutS+0x148>)
 80005f4:	46b8      	mov	r8, r7
 80005f6:	e7bf      	b.n	8000578 <chSchGoSleepTimeoutS+0xa8>
 80005f8:	4907      	ldr	r1, [pc, #28]	; (8000618 <chSchGoSleepTimeoutS+0x148>)
 80005fa:	e7f1      	b.n	80005e0 <chSchGoSleepTimeoutS+0x110>
 80005fc:	4b06      	ldr	r3, [pc, #24]	; (8000618 <chSchGoSleepTimeoutS+0x148>)
 80005fe:	e7e0      	b.n	80005c2 <chSchGoSleepTimeoutS+0xf2>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8000600:	1c93      	adds	r3, r2, #2
 8000602:	e7de      	b.n	80005c2 <chSchGoSleepTimeoutS+0xf2>
  STM32_ST_TIM->DIER = 0U;
 8000604:	4b03      	ldr	r3, [pc, #12]	; (8000614 <chSchGoSleepTimeoutS+0x144>)
 8000606:	60d9      	str	r1, [r3, #12]
    return;
 8000608:	e7a6      	b.n	8000558 <chSchGoSleepTimeoutS+0x88>
 800060a:	46c0      	nop			; (mov r8, r8)
 800060c:	20000460 	.word	0x20000460
 8000610:	08000341 	.word	0x08000341
 8000614:	40000400 	.word	0x40000400
 8000618:	0000ffff 	.word	0x0000ffff
 800061c:	00000000 	.word	0x00000000

08000620 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8000620:	b510      	push	{r4, lr}

  if (TIME_IMMEDIATE == timeout) {
 8000622:	2900      	cmp	r1, #0
 8000624:	d00a      	beq.n	800063c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000626:	4b07      	ldr	r3, [pc, #28]	; (8000644 <chThdEnqueueTimeoutS+0x24>)
  tp->queue.prev             = tqp->prev;
 8000628:	6842      	ldr	r2, [r0, #4]
 800062a:	699b      	ldr	r3, [r3, #24]
  tp->queue.next             = (thread_t *)tqp;
 800062c:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800062e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8000630:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 8000632:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000634:	2004      	movs	r0, #4
 8000636:	f7ff ff4b 	bl	80004d0 <chSchGoSleepTimeoutS>
}
 800063a:	bd10      	pop	{r4, pc}
    return MSG_TIMEOUT;
 800063c:	2001      	movs	r0, #1
 800063e:	4240      	negs	r0, r0
 8000640:	e7fb      	b.n	800063a <chThdEnqueueTimeoutS+0x1a>
 8000642:	46c0      	nop			; (mov r8, r8)
 8000644:	20000460 	.word	0x20000460
	...

08000650 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000650:	b570      	push	{r4, r5, r6, lr}
 8000652:	0004      	movs	r4, r0
 8000654:	000e      	movs	r6, r1
 8000656:	0015      	movs	r5, r2
  __ASM volatile ("cpsid i" : : : "memory");
 8000658:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800065a:	e005      	b.n	8000668 <oqPutTimeout+0x18>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
 800065c:	0029      	movs	r1, r5
 800065e:	0020      	movs	r0, r4
 8000660:	f7ff ffde 	bl	8000620 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000664:	2800      	cmp	r0, #0
 8000666:	db17      	blt.n	8000698 <oqPutTimeout+0x48>
  while (oqIsFullI(oqp)) {
 8000668:	68a3      	ldr	r3, [r4, #8]
 800066a:	2b00      	cmp	r3, #0
 800066c:	d0f6      	beq.n	800065c <oqPutTimeout+0xc>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 800066e:	68a3      	ldr	r3, [r4, #8]
 8000670:	3b01      	subs	r3, #1
 8000672:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000674:	6963      	ldr	r3, [r4, #20]
 8000676:	1c5a      	adds	r2, r3, #1
 8000678:	6162      	str	r2, [r4, #20]
 800067a:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800067c:	6963      	ldr	r3, [r4, #20]
 800067e:	6922      	ldr	r2, [r4, #16]
 8000680:	4293      	cmp	r3, r2
 8000682:	d301      	bcc.n	8000688 <oqPutTimeout+0x38>
    oqp->q_wrptr = oqp->q_buffer;
 8000684:	68e3      	ldr	r3, [r4, #12]
 8000686:	6163      	str	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8000688:	69e3      	ldr	r3, [r4, #28]
 800068a:	2b00      	cmp	r3, #0
 800068c:	d001      	beq.n	8000692 <oqPutTimeout+0x42>
    oqp->q_notify(oqp);
 800068e:	0020      	movs	r0, r4
 8000690:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
 8000692:	b662      	cpsie	i
 8000694:	2000      	movs	r0, #0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000696:	bd70      	pop	{r4, r5, r6, pc}
 8000698:	b662      	cpsie	i
      return msg;
 800069a:	e7fc      	b.n	8000696 <oqPutTimeout+0x46>
 800069c:	0000      	movs	r0, r0
	...

080006a0 <_putt>:
static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 80006a0:	b510      	push	{r4, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80006a2:	3030      	adds	r0, #48	; 0x30
 80006a4:	f7ff ffd4 	bl	8000650 <oqPutTimeout>
}
 80006a8:	bd10      	pop	{r4, pc}
 80006aa:	46c0      	nop			; (mov r8, r8)
 80006ac:	0000      	movs	r0, r0
	...

080006b0 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80006b0:	2201      	movs	r2, #1
static msg_t _put(void *ip, uint8_t b) {
 80006b2:	b510      	push	{r4, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80006b4:	3030      	adds	r0, #48	; 0x30
 80006b6:	4252      	negs	r2, r2
 80006b8:	f7ff ffca 	bl	8000650 <oqPutTimeout>
}
 80006bc:	bd10      	pop	{r4, pc}
 80006be:	46c0      	nop			; (mov r8, r8)

080006c0 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 80006c0:	b570      	push	{r4, r5, r6, lr}
 80006c2:	0005      	movs	r5, r0
 80006c4:	000c      	movs	r4, r1
  __ASM volatile ("cpsid i" : : : "memory");
 80006c6:	b672      	cpsid	i
 80006c8:	e005      	b.n	80006d6 <iqGetTimeout+0x16>
 80006ca:	0021      	movs	r1, r4
 80006cc:	0028      	movs	r0, r5
 80006ce:	f7ff ffa7 	bl	8000620 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80006d2:	2800      	cmp	r0, #0
 80006d4:	db16      	blt.n	8000704 <iqGetTimeout+0x44>
  while (iqIsEmptyI(iqp)) {
 80006d6:	68ab      	ldr	r3, [r5, #8]
 80006d8:	2b00      	cmp	r3, #0
 80006da:	d0f6      	beq.n	80006ca <iqGetTimeout+0xa>
  iqp->q_counter--;
 80006dc:	68ab      	ldr	r3, [r5, #8]
  b = *iqp->q_rdptr++;
 80006de:	69aa      	ldr	r2, [r5, #24]
  iqp->q_counter--;
 80006e0:	3b01      	subs	r3, #1
 80006e2:	60ab      	str	r3, [r5, #8]
  b = *iqp->q_rdptr++;
 80006e4:	1c53      	adds	r3, r2, #1
 80006e6:	61ab      	str	r3, [r5, #24]
 80006e8:	7814      	ldrb	r4, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 80006ea:	692a      	ldr	r2, [r5, #16]
 80006ec:	4293      	cmp	r3, r2
 80006ee:	d301      	bcc.n	80006f4 <iqGetTimeout+0x34>
    iqp->q_rdptr = iqp->q_buffer;
 80006f0:	68eb      	ldr	r3, [r5, #12]
 80006f2:	61ab      	str	r3, [r5, #24]
  if (iqp->q_notify != NULL) {
 80006f4:	69eb      	ldr	r3, [r5, #28]
 80006f6:	2b00      	cmp	r3, #0
 80006f8:	d001      	beq.n	80006fe <iqGetTimeout+0x3e>
    iqp->q_notify(iqp);
 80006fa:	0028      	movs	r0, r5
 80006fc:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
 80006fe:	b662      	cpsie	i
  return (msg_t)b;
 8000700:	0020      	movs	r0, r4
}
 8000702:	bd70      	pop	{r4, r5, r6, pc}
 8000704:	b662      	cpsie	i
      return msg;
 8000706:	e7fc      	b.n	8000702 <iqGetTimeout+0x42>
	...

08000710 <_gett>:
static msg_t _gett(void *ip, sysinterval_t timeout) {
 8000710:	b510      	push	{r4, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000712:	300c      	adds	r0, #12
 8000714:	f7ff ffd4 	bl	80006c0 <iqGetTimeout>
}
 8000718:	bd10      	pop	{r4, pc}
 800071a:	46c0      	nop			; (mov r8, r8)
 800071c:	0000      	movs	r0, r0
	...

08000720 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000720:	2101      	movs	r1, #1
static msg_t _get(void *ip) {
 8000722:	b510      	push	{r4, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000724:	300c      	adds	r0, #12
 8000726:	4249      	negs	r1, r1
 8000728:	f7ff ffca 	bl	80006c0 <iqGetTimeout>
}
 800072c:	bd10      	pop	{r4, pc}
 800072e:	46c0      	nop			; (mov r8, r8)

08000730 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000730:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000732:	46de      	mov	lr, fp
 8000734:	464e      	mov	r6, r9
 8000736:	4645      	mov	r5, r8
 8000738:	4657      	mov	r7, sl
 800073a:	b5e0      	push	{r5, r6, r7, lr}
 800073c:	469b      	mov	fp, r3
  qnotify_t nfy = oqp->q_notify;
 800073e:	69c3      	ldr	r3, [r0, #28]
                      size_t n, sysinterval_t timeout) {
 8000740:	b083      	sub	sp, #12
 8000742:	0004      	movs	r4, r0
 8000744:	4688      	mov	r8, r1
  qnotify_t nfy = oqp->q_notify;
 8000746:	4699      	mov	r9, r3
                      size_t n, sysinterval_t timeout) {
 8000748:	9201      	str	r2, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 800074a:	b672      	cpsid	i

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 800074c:	1e17      	subs	r7, r2, #0
 800074e:	d027      	beq.n	80007a0 <oqWriteTimeout+0x70>
  if (n > oqGetEmptyI(oqp)) {
 8000750:	68a3      	ldr	r3, [r4, #8]
 8000752:	003d      	movs	r5, r7
 8000754:	429f      	cmp	r7, r3
 8000756:	d900      	bls.n	800075a <oqWriteTimeout+0x2a>
    n = oqGetEmptyI(oqp);
 8000758:	68a5      	ldr	r5, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 800075a:	6960      	ldr	r0, [r4, #20]
 800075c:	6923      	ldr	r3, [r4, #16]
 800075e:	1a1e      	subs	r6, r3, r0
  if (n < s1) {
 8000760:	42ae      	cmp	r6, r5
 8000762:	d83a      	bhi.n	80007da <oqWriteTimeout+0xaa>
  else if (n > s1) {
 8000764:	d225      	bcs.n	80007b2 <oqWriteTimeout+0x82>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000766:	0032      	movs	r2, r6
 8000768:	4641      	mov	r1, r8
 800076a:	f7ff fd37 	bl	80001dc <memcpy>
    bp += s1;
 800076e:	0031      	movs	r1, r6
    s2 = n - s1;
 8000770:	1bab      	subs	r3, r5, r6
 8000772:	469a      	mov	sl, r3
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000774:	001a      	movs	r2, r3
 8000776:	68e0      	ldr	r0, [r4, #12]
    bp += s1;
 8000778:	4441      	add	r1, r8
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 800077a:	f7ff fd2f 	bl	80001dc <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 800077e:	68e3      	ldr	r3, [r4, #12]
 8000780:	4453      	add	r3, sl
 8000782:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 8000784:	68a3      	ldr	r3, [r4, #8]
 8000786:	1b5b      	subs	r3, r3, r5
 8000788:	60a3      	str	r3, [r4, #8]
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 800078a:	464b      	mov	r3, r9
 800078c:	2b00      	cmp	r3, #0
 800078e:	d001      	beq.n	8000794 <oqWriteTimeout+0x64>
        nfy(oqp);
 8000790:	0020      	movs	r0, r4
 8000792:	47c8      	blx	r9
  __ASM volatile ("cpsie i" : : : "memory");
 8000794:	b662      	cpsie	i
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 8000796:	1b7f      	subs	r7, r7, r5
      bp += done;
 8000798:	44a8      	add	r8, r5
  __ASM volatile ("cpsid i" : : : "memory");
 800079a:	b672      	cpsid	i
  while (n > 0U) {
 800079c:	2f00      	cmp	r7, #0
 800079e:	d1d7      	bne.n	8000750 <oqWriteTimeout+0x20>
  if (n > oqGetEmptyI(oqp)) {
 80007a0:	9801      	ldr	r0, [sp, #4]
  __ASM volatile ("cpsie i" : : : "memory");
 80007a2:	b662      	cpsie	i
    }
  }

  osalSysUnlock();
  return max - n;
}
 80007a4:	b003      	add	sp, #12
 80007a6:	bc3c      	pop	{r2, r3, r4, r5}
 80007a8:	4690      	mov	r8, r2
 80007aa:	4699      	mov	r9, r3
 80007ac:	46a2      	mov	sl, r4
 80007ae:	46ab      	mov	fp, r5
 80007b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80007b2:	002a      	movs	r2, r5
 80007b4:	4641      	mov	r1, r8
 80007b6:	f7ff fd11 	bl	80001dc <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 80007ba:	68e3      	ldr	r3, [r4, #12]
 80007bc:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 80007be:	68a3      	ldr	r3, [r4, #8]
 80007c0:	1b5b      	subs	r3, r3, r5
 80007c2:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 80007c4:	2d00      	cmp	r5, #0
 80007c6:	d1e0      	bne.n	800078a <oqWriteTimeout+0x5a>
 80007c8:	4659      	mov	r1, fp
 80007ca:	0020      	movs	r0, r4
 80007cc:	f7ff ff28 	bl	8000620 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 80007d0:	2800      	cmp	r0, #0
 80007d2:	d0bd      	beq.n	8000750 <oqWriteTimeout+0x20>
 80007d4:	9b01      	ldr	r3, [sp, #4]
 80007d6:	1bd8      	subs	r0, r3, r7
 80007d8:	e7e3      	b.n	80007a2 <oqWriteTimeout+0x72>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80007da:	002a      	movs	r2, r5
 80007dc:	4641      	mov	r1, r8
 80007de:	f7ff fcfd 	bl	80001dc <memcpy>
    oqp->q_wrptr += n;
 80007e2:	6963      	ldr	r3, [r4, #20]
 80007e4:	195b      	adds	r3, r3, r5
 80007e6:	6163      	str	r3, [r4, #20]
 80007e8:	e7e9      	b.n	80007be <oqWriteTimeout+0x8e>
 80007ea:	46c0      	nop			; (mov r8, r8)
 80007ec:	0000      	movs	r0, r0
	...

080007f0 <_writet>:
                      sysinterval_t timeout) {
 80007f0:	b510      	push	{r4, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80007f2:	3030      	adds	r0, #48	; 0x30
 80007f4:	f7ff ff9c 	bl	8000730 <oqWriteTimeout>
}
 80007f8:	bd10      	pop	{r4, pc}
 80007fa:	46c0      	nop			; (mov r8, r8)
 80007fc:	0000      	movs	r0, r0
	...

08000800 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000800:	2301      	movs	r3, #1
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8000802:	b510      	push	{r4, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000804:	3030      	adds	r0, #48	; 0x30
 8000806:	425b      	negs	r3, r3
 8000808:	f7ff ff92 	bl	8000730 <oqWriteTimeout>
}
 800080c:	bd10      	pop	{r4, pc}
 800080e:	46c0      	nop			; (mov r8, r8)

08000810 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8000810:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000812:	46de      	mov	lr, fp
 8000814:	464e      	mov	r6, r9
 8000816:	4645      	mov	r5, r8
 8000818:	4657      	mov	r7, sl
 800081a:	b5e0      	push	{r5, r6, r7, lr}
 800081c:	469b      	mov	fp, r3
  qnotify_t nfy = iqp->q_notify;
 800081e:	69c3      	ldr	r3, [r0, #28]
                     size_t n, sysinterval_t timeout) {
 8000820:	b083      	sub	sp, #12
 8000822:	0004      	movs	r4, r0
 8000824:	4688      	mov	r8, r1
  qnotify_t nfy = iqp->q_notify;
 8000826:	4699      	mov	r9, r3
                     size_t n, sysinterval_t timeout) {
 8000828:	9201      	str	r2, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 800082a:	b672      	cpsid	i
  while (n > 0U) {
 800082c:	1e17      	subs	r7, r2, #0
 800082e:	d027      	beq.n	8000880 <iqReadTimeout+0x70>
  if (n > iqGetFullI(iqp)) {
 8000830:	68a3      	ldr	r3, [r4, #8]
 8000832:	003d      	movs	r5, r7
 8000834:	429f      	cmp	r7, r3
 8000836:	d900      	bls.n	800083a <iqReadTimeout+0x2a>
    n = iqGetFullI(iqp);
 8000838:	68a5      	ldr	r5, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800083a:	69a1      	ldr	r1, [r4, #24]
 800083c:	6923      	ldr	r3, [r4, #16]
 800083e:	1a5e      	subs	r6, r3, r1
  if (n < s1) {
 8000840:	42ae      	cmp	r6, r5
 8000842:	d83a      	bhi.n	80008ba <iqReadTimeout+0xaa>
  else if (n > s1) {
 8000844:	d225      	bcs.n	8000892 <iqReadTimeout+0x82>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000846:	0032      	movs	r2, r6
 8000848:	4640      	mov	r0, r8
 800084a:	f7ff fcc7 	bl	80001dc <memcpy>
    bp += s1;
 800084e:	0030      	movs	r0, r6
    s2 = n - s1;
 8000850:	1bab      	subs	r3, r5, r6
 8000852:	469a      	mov	sl, r3
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8000854:	001a      	movs	r2, r3
 8000856:	68e1      	ldr	r1, [r4, #12]
    bp += s1;
 8000858:	4440      	add	r0, r8
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 800085a:	f7ff fcbf 	bl	80001dc <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 800085e:	68e3      	ldr	r3, [r4, #12]
 8000860:	4453      	add	r3, sl
 8000862:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 8000864:	68a3      	ldr	r3, [r4, #8]
 8000866:	1b5b      	subs	r3, r3, r5
 8000868:	60a3      	str	r3, [r4, #8]
      if (nfy != NULL) {
 800086a:	464b      	mov	r3, r9
 800086c:	2b00      	cmp	r3, #0
 800086e:	d001      	beq.n	8000874 <iqReadTimeout+0x64>
        nfy(iqp);
 8000870:	0020      	movs	r0, r4
 8000872:	47c8      	blx	r9
  __ASM volatile ("cpsie i" : : : "memory");
 8000874:	b662      	cpsie	i
      n  -= done;
 8000876:	1b7f      	subs	r7, r7, r5
      bp += done;
 8000878:	44a8      	add	r8, r5
  __ASM volatile ("cpsid i" : : : "memory");
 800087a:	b672      	cpsid	i
  while (n > 0U) {
 800087c:	2f00      	cmp	r7, #0
 800087e:	d1d7      	bne.n	8000830 <iqReadTimeout+0x20>
  if (n > iqGetFullI(iqp)) {
 8000880:	9801      	ldr	r0, [sp, #4]
  __ASM volatile ("cpsie i" : : : "memory");
 8000882:	b662      	cpsie	i
}
 8000884:	b003      	add	sp, #12
 8000886:	bc3c      	pop	{r2, r3, r4, r5}
 8000888:	4690      	mov	r8, r2
 800088a:	4699      	mov	r9, r3
 800088c:	46a2      	mov	sl, r4
 800088e:	46ab      	mov	fp, r5
 8000890:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000892:	002a      	movs	r2, r5
 8000894:	4640      	mov	r0, r8
 8000896:	f7ff fca1 	bl	80001dc <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 800089a:	68e3      	ldr	r3, [r4, #12]
 800089c:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 800089e:	68a3      	ldr	r3, [r4, #8]
 80008a0:	1b5b      	subs	r3, r3, r5
 80008a2:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
 80008a4:	2d00      	cmp	r5, #0
 80008a6:	d1e0      	bne.n	800086a <iqReadTimeout+0x5a>
 80008a8:	4659      	mov	r1, fp
 80008aa:	0020      	movs	r0, r4
 80008ac:	f7ff feb8 	bl	8000620 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 80008b0:	2800      	cmp	r0, #0
 80008b2:	d0bd      	beq.n	8000830 <iqReadTimeout+0x20>
 80008b4:	9b01      	ldr	r3, [sp, #4]
 80008b6:	1bd8      	subs	r0, r3, r7
 80008b8:	e7e3      	b.n	8000882 <iqReadTimeout+0x72>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 80008ba:	002a      	movs	r2, r5
 80008bc:	4640      	mov	r0, r8
 80008be:	f7ff fc8d 	bl	80001dc <memcpy>
    iqp->q_rdptr += n;
 80008c2:	69a3      	ldr	r3, [r4, #24]
 80008c4:	195b      	adds	r3, r3, r5
 80008c6:	61a3      	str	r3, [r4, #24]
 80008c8:	e7e9      	b.n	800089e <iqReadTimeout+0x8e>
 80008ca:	46c0      	nop			; (mov r8, r8)
 80008cc:	0000      	movs	r0, r0
	...

080008d0 <_readt>:
                     sysinterval_t timeout) {
 80008d0:	b510      	push	{r4, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80008d2:	300c      	adds	r0, #12
 80008d4:	f7ff ff9c 	bl	8000810 <iqReadTimeout>
}
 80008d8:	bd10      	pop	{r4, pc}
 80008da:	46c0      	nop			; (mov r8, r8)
 80008dc:	0000      	movs	r0, r0
	...

080008e0 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80008e0:	2301      	movs	r3, #1
static size_t _read(void *ip, uint8_t *bp, size_t n) {
 80008e2:	b510      	push	{r4, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80008e4:	300c      	adds	r0, #12
 80008e6:	425b      	negs	r3, r3
 80008e8:	f7ff ff92 	bl	8000810 <iqReadTimeout>
}
 80008ec:	bd10      	pop	{r4, pc}
 80008ee:	46c0      	nop			; (mov r8, r8)

080008f0 <main>:
void hal_lld_init(void) {

  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
 80008f0:	4bce      	ldr	r3, [pc, #824]	; (8000c2c <main+0x33c>)
 */

/*
 * Application entry point.
 */
int main(void) {
 80008f2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80008f4:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80008f6:	46d6      	mov	lr, sl
 80008f8:	464f      	mov	r7, r9
 80008fa:	4646      	mov	r6, r8
 80008fc:	4acc      	ldr	r2, [pc, #816]	; (8000c30 <main+0x340>)
 80008fe:	b5c0      	push	{r6, r7, lr}
 8000900:	430a      	orrs	r2, r1
 8000902:	21bc      	movs	r1, #188	; 0xbc
 8000904:	629a      	str	r2, [r3, #40]	; 0x28
 8000906:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000908:	03c9      	lsls	r1, r1, #15
 800090a:	400a      	ands	r2, r1
 800090c:	629a      	str	r2, [r3, #40]	; 0x28
 800090e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000910:	691a      	ldr	r2, [r3, #16]
 8000912:	2201      	movs	r2, #1
 8000914:	2100      	movs	r1, #0
 8000916:	4252      	negs	r2, r2
 8000918:	611a      	str	r2, [r3, #16]
 800091a:	691a      	ldr	r2, [r3, #16]
 800091c:	6119      	str	r1, [r3, #16]
 800091e:	691a      	ldr	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000920:	68d8      	ldr	r0, [r3, #12]
 8000922:	4ac4      	ldr	r2, [pc, #784]	; (8000c34 <main+0x344>)
 8000924:	4302      	orrs	r2, r0
 8000926:	2080      	movs	r0, #128	; 0x80
 8000928:	60da      	str	r2, [r3, #12]
 800092a:	68da      	ldr	r2, [r3, #12]
 800092c:	03c0      	lsls	r0, r0, #15
 800092e:	4002      	ands	r2, r0
 8000930:	60da      	str	r2, [r3, #12]
 8000932:	68da      	ldr	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8000934:	2280      	movs	r2, #128	; 0x80
 8000936:	69d8      	ldr	r0, [r3, #28]
 8000938:	0552      	lsls	r2, r2, #21
 800093a:	4302      	orrs	r2, r0
 800093c:	61da      	str	r2, [r3, #28]
 800093e:	69da      	ldr	r2, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 8000940:	2280      	movs	r2, #128	; 0x80
 8000942:	48bd      	ldr	r0, [pc, #756]	; (8000c38 <main+0x348>)
 8000944:	0052      	lsls	r2, r2, #1
 8000946:	6804      	ldr	r4, [r0, #0]
 8000948:	4322      	orrs	r2, r4
 800094a:	6002      	str	r2, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800094c:	20c0      	movs	r0, #192	; 0xc0
 800094e:	6a1a      	ldr	r2, [r3, #32]
 8000950:	0080      	lsls	r0, r0, #2
 8000952:	4002      	ands	r2, r0
 8000954:	3801      	subs	r0, #1
 8000956:	38ff      	subs	r0, #255	; 0xff
 8000958:	4282      	cmp	r2, r0
 800095a:	d003      	beq.n	8000964 <main+0x74>
    RCC->BDCR = RCC_BDCR_BDRST;
 800095c:	2280      	movs	r2, #128	; 0x80
 800095e:	0252      	lsls	r2, r2, #9
 8000960:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8000962:	6219      	str	r1, [r3, #32]
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000964:	2280      	movs	r2, #128	; 0x80
 8000966:	4bb1      	ldr	r3, [pc, #708]	; (8000c2c <main+0x33c>)
 8000968:	0212      	lsls	r2, r2, #8
 800096a:	6a19      	ldr	r1, [r3, #32]
 800096c:	4211      	tst	r1, r2
 800096e:	d107      	bne.n	8000980 <main+0x90>
    RCC->BDCR |= STM32_RTCSEL;
 8000970:	2180      	movs	r1, #128	; 0x80
 8000972:	6a18      	ldr	r0, [r3, #32]
 8000974:	0089      	lsls	r1, r1, #2
 8000976:	4301      	orrs	r1, r0
 8000978:	6219      	str	r1, [r3, #32]
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800097a:	6a19      	ldr	r1, [r3, #32]
 800097c:	430a      	orrs	r2, r1
 800097e:	621a      	str	r2, [r3, #32]
 * @notapi
 */
void irqInit(void) {

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_1_IRQn, STM32_IRQ_EXTI0_1_PRIORITY);
 8000980:	2103      	movs	r1, #3
 8000982:	2005      	movs	r0, #5
 8000984:	f7ff fd64 	bl	8000450 <nvicEnableVector>
  nvicEnableVector(EXTI2_3_IRQn, STM32_IRQ_EXTI2_3_PRIORITY);
 8000988:	2103      	movs	r1, #3
 800098a:	2006      	movs	r0, #6
 800098c:	f7ff fd60 	bl	8000450 <nvicEnableVector>
  nvicEnableVector(EXTI4_15_IRQn, STM32_IRQ_EXTI4_15_PRIORITY);
 8000990:	2103      	movs	r1, #3
 8000992:	2007      	movs	r0, #7
 8000994:	f7ff fd5c 	bl	8000450 <nvicEnableVector>
#endif

#if HAL_USE_SERIAL || HAL_USE_UART
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
 8000998:	2103      	movs	r1, #3
 800099a:	201b      	movs	r0, #27
 800099c:	f7ff fd58 	bl	8000450 <nvicEnableVector>
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
 80009a0:	2103      	movs	r1, #3
 80009a2:	201c      	movs	r0, #28
 80009a4:	f7ff fd54 	bl	8000450 <nvicEnableVector>
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_IRQ_USART3_8_PRIORITY);
 80009a8:	2103      	movs	r1, #3
 80009aa:	201d      	movs	r0, #29
 80009ac:	f7ff fd50 	bl	8000450 <nvicEnableVector>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {

  sdp->vmt = &vmt;
 80009b0:	4ba2      	ldr	r3, [pc, #648]	; (8000c3c <main+0x34c>)
 80009b2:	49a3      	ldr	r1, [pc, #652]	; (8000c40 <main+0x350>)
 80009b4:	001a      	movs	r2, r3
 80009b6:	c202      	stmia	r2!, {r1}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 80009b8:	605a      	str	r2, [r3, #4]
  tqp->next = (thread_t *)tqp;
 80009ba:	001a      	movs	r2, r3
 80009bc:	320c      	adds	r2, #12
 80009be:	60da      	str	r2, [r3, #12]
  tqp->prev = (thread_t *)tqp;
 80009c0:	611a      	str	r2, [r3, #16]
  iqp->q_buffer  = bp;
 80009c2:	4aa0      	ldr	r2, [pc, #640]	; (8000c44 <main+0x354>)
  iqp->q_counter = 0;
 80009c4:	2400      	movs	r4, #0
  iqp->q_buffer  = bp;
 80009c6:	619a      	str	r2, [r3, #24]
  iqp->q_rdptr   = bp;
 80009c8:	625a      	str	r2, [r3, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80009ca:	621a      	str	r2, [r3, #32]
  iqp->q_top     = bp + size;
 80009cc:	3210      	adds	r2, #16
 80009ce:	61da      	str	r2, [r3, #28]
  tqp->next = (thread_t *)tqp;
 80009d0:	001a      	movs	r2, r3
 80009d2:	3230      	adds	r2, #48	; 0x30
 80009d4:	631a      	str	r2, [r3, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 80009d6:	635a      	str	r2, [r3, #52]	; 0x34
  oqp->q_counter = size;
 80009d8:	2210      	movs	r2, #16
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80009da:	2501      	movs	r5, #1

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80009dc:	2602      	movs	r6, #2
  iqp->q_counter = 0;
 80009de:	615c      	str	r4, [r3, #20]
  oqp->q_counter = size;
 80009e0:	639a      	str	r2, [r3, #56]	; 0x38
  oqp->q_buffer  = bp;
 80009e2:	4a99      	ldr	r2, [pc, #612]	; (8000c48 <main+0x358>)
 80009e4:	721d      	strb	r5, [r3, #8]
 80009e6:	63da      	str	r2, [r3, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80009e8:	649a      	str	r2, [r3, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80009ea:	645a      	str	r2, [r3, #68]	; 0x44
  oqp->q_top     = bp + size;
 80009ec:	3210      	adds	r2, #16
 80009ee:	641a      	str	r2, [r3, #64]	; 0x40
  oqp->q_notify  = onfy;
 80009f0:	4a96      	ldr	r2, [pc, #600]	; (8000c4c <main+0x35c>)
  iqp->q_notify  = infy;
 80009f2:	629c      	str	r4, [r3, #40]	; 0x28
  oqp->q_notify  = onfy;
 80009f4:	64da      	str	r2, [r3, #76]	; 0x4c

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2);
  iqObjectInit(&SD2.iqueue, sd_in_buf2, sizeof sd_in_buf2, NULL, &SD2);
  oqObjectInit(&SD2.oqueue, sd_out_buf2, sizeof sd_out_buf2, notify2, &SD2);
  SD2.usart = USART2;
 80009f6:	4a96      	ldr	r2, [pc, #600]	; (8000c50 <main+0x360>)
  iqp->q_link    = link;
 80009f8:	62db      	str	r3, [r3, #44]	; 0x2c
 80009fa:	655a      	str	r2, [r3, #84]	; 0x54
  SD2.clock = STM32_USART2CLK;
 80009fc:	4a95      	ldr	r2, [pc, #596]	; (8000c54 <main+0x364>)
  oqp->q_link    = link;
 80009fe:	651b      	str	r3, [r3, #80]	; 0x50
 8000a00:	659a      	str	r2, [r3, #88]	; 0x58
 8000a02:	4b8a      	ldr	r3, [pc, #552]	; (8000c2c <main+0x33c>)
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

#if !defined(STM32_SYSTICK_SUPPRESS_ISR)
  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8000a04:	2102      	movs	r1, #2
  ST_ENABLE_CLOCK();
 8000a06:	69da      	ldr	r2, [r3, #28]
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8000a08:	2010      	movs	r0, #16
  ST_ENABLE_CLOCK();
 8000a0a:	4332      	orrs	r2, r6
 8000a0c:	61da      	str	r2, [r3, #28]
  ST_ENABLE_STOP();
 8000a0e:	4a92      	ldr	r2, [pc, #584]	; (8000c58 <main+0x368>)
  ST_ENABLE_CLOCK();
 8000a10:	69db      	ldr	r3, [r3, #28]
  ST_ENABLE_STOP();
 8000a12:	6893      	ldr	r3, [r2, #8]
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
  mp->align = align;
 8000a14:	2704      	movs	r7, #4
 8000a16:	4333      	orrs	r3, r6
 8000a18:	6093      	str	r3, [r2, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000a1a:	4b90      	ldr	r3, [pc, #576]	; (8000c5c <main+0x36c>)
 8000a1c:	4a90      	ldr	r2, [pc, #576]	; (8000c60 <main+0x370>)
 8000a1e:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000a20:	4a90      	ldr	r2, [pc, #576]	; (8000c64 <main+0x374>)
 8000a22:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8000a24:	619c      	str	r4, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8000a26:	635c      	str	r4, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8000a28:	60dc      	str	r4, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000a2a:	605c      	str	r4, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8000a2c:	615d      	str	r5, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000a2e:	601d      	str	r5, [r3, #0]
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8000a30:	f7ff fd0e 	bl	8000450 <nvicEnableVector>
  tqp->next = (thread_t *)tqp;
 8000a34:	4b8c      	ldr	r3, [pc, #560]	; (8000c68 <main+0x378>)
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8000a36:	2024      	movs	r0, #36	; 0x24
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000a38:	001a      	movs	r2, r3
 8000a3a:	321c      	adds	r2, #28
 8000a3c:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8000a3e:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 8000a40:	2201      	movs	r2, #1
 8000a42:	4252      	negs	r2, r2
 8000a44:	625a      	str	r2, [r3, #36]	; 0x24
  ch.vtlist.lasttime = (systime_t)0;
 8000a46:	2200      	movs	r2, #0
  ch_memcore.basemem = __heap_base__;
 8000a48:	4988      	ldr	r1, [pc, #544]	; (8000c6c <main+0x37c>)
 8000a4a:	4691      	mov	r9, r2
 8000a4c:	4a88      	ldr	r2, [pc, #544]	; (8000c70 <main+0x380>)
 8000a4e:	4684      	mov	ip, r0
 8000a50:	6011      	str	r1, [r2, #0]
  ch_memcore.topmem  = __heap_end__;
 8000a52:	4988      	ldr	r1, [pc, #544]	; (8000c74 <main+0x384>)
 8000a54:	601b      	str	r3, [r3, #0]
 8000a56:	6051      	str	r1, [r2, #4]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8000a58:	4a87      	ldr	r2, [pc, #540]	; (8000c78 <main+0x388>)
 8000a5a:	4988      	ldr	r1, [pc, #544]	; (8000c7c <main+0x38c>)
  H_NEXT(&default_heap.header) = NULL;
 8000a5c:	6054      	str	r4, [r2, #4]
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8000a5e:	6011      	str	r1, [r2, #0]
 8000a60:	0011      	movs	r1, r2
 8000a62:	310c      	adds	r1, #12
  H_PAGES(&default_heap.header) = 0;
 8000a64:	6094      	str	r4, [r2, #8]
  tqp->prev = (thread_t *)tqp;
 8000a66:	6111      	str	r1, [r2, #16]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000a68:	6154      	str	r4, [r2, #20]
  tqp->next = (thread_t *)tqp;
 8000a6a:	60d1      	str	r1, [r2, #12]
 8000a6c:	4a84      	ldr	r2, [pc, #528]	; (8000c80 <main+0x390>)
  tqp->prev = (thread_t *)tqp;
 8000a6e:	605b      	str	r3, [r3, #4]
 8000a70:	4494      	add	ip, r2
 8000a72:	4660      	mov	r0, ip
 8000a74:	6250      	str	r0, [r2, #36]	; 0x24
 8000a76:	2028      	movs	r0, #40	; 0x28
 8000a78:	0011      	movs	r1, r2
 8000a7a:	4684      	mov	ip, r0
 8000a7c:	3110      	adds	r1, #16
 8000a7e:	6111      	str	r1, [r2, #16]
  mp->object_size = size;
 8000a80:	2114      	movs	r1, #20
 8000a82:	4494      	add	ip, r2
 8000a84:	4660      	mov	r0, ip
 8000a86:	6191      	str	r1, [r2, #24]
  mp->provider = provider;
 8000a88:	497e      	ldr	r1, [pc, #504]	; (8000c84 <main+0x394>)
 8000a8a:	6094      	str	r4, [r2, #8]
  mp->next = NULL;
 8000a8c:	6154      	str	r4, [r2, #20]
  mp->align = align;
 8000a8e:	61d7      	str	r7, [r2, #28]
  mp->provider = provider;
 8000a90:	6211      	str	r1, [r2, #32]
  ch.rlist.prio = NOPRIO;
 8000a92:	609c      	str	r4, [r3, #8]
 8000a94:	851c      	strh	r4, [r3, #40]	; 0x28
  tqp->next = (thread_t *)tqp;
 8000a96:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8000a98:	6052      	str	r2, [r2, #4]
 8000a9a:	6290      	str	r0, [r2, #40]	; 0x28
 8000a9c:	6391      	str	r1, [r2, #56]	; 0x38
 8000a9e:	0011      	movs	r1, r2
 8000aa0:	313c      	adds	r1, #60	; 0x3c
 8000aa2:	63d1      	str	r1, [r2, #60]	; 0x3c
 8000aa4:	0011      	movs	r1, r2
 8000aa6:	3140      	adds	r1, #64	; 0x40
 8000aa8:	6411      	str	r1, [r2, #64]	; 0x40
 8000aaa:	0011      	movs	r1, r2
  mp->object_size = size;
 8000aac:	201c      	movs	r0, #28
 8000aae:	3144      	adds	r1, #68	; 0x44
 8000ab0:	6310      	str	r0, [r2, #48]	; 0x30
  mp->align = align;
 8000ab2:	6357      	str	r7, [r2, #52]	; 0x34
 8000ab4:	6451      	str	r1, [r2, #68]	; 0x44
  mp->next = NULL;
 8000ab6:	62d4      	str	r4, [r2, #44]	; 0x2c
  tp->name      = name;
 8000ab8:	4a73      	ldr	r2, [pc, #460]	; (8000c88 <main+0x398>)
  tp->prio      = prio;
 8000aba:	2180      	movs	r1, #128	; 0x80
  tp->name      = name;
 8000abc:	649a      	str	r2, [r3, #72]	; 0x48
  REG_INSERT(tp);
 8000abe:	001a      	movs	r2, r3
 8000ac0:	3230      	adds	r2, #48	; 0x30
 8000ac2:	611a      	str	r2, [r3, #16]
 8000ac4:	615a      	str	r2, [r3, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8000ac6:	619a      	str	r2, [r3, #24]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8000ac8:	2201      	movs	r2, #1
 8000aca:	4692      	mov	sl, r2
 8000acc:	2250      	movs	r2, #80	; 0x50
  tp->refs      = (trefs_t)1;
 8000ace:	4650      	mov	r0, sl
 8000ad0:	529d      	strh	r5, [r3, r2]
 8000ad2:	3202      	adds	r2, #2
 8000ad4:	5498      	strb	r0, [r3, r2]
  tlp->next = (thread_t *)tlp;
 8000ad6:	001f      	movs	r7, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8000ad8:	4a6c      	ldr	r2, [pc, #432]	; (8000c8c <main+0x39c>)
  tp->prio      = prio;
 8000ada:	6399      	str	r1, [r3, #56]	; 0x38
 8000adc:	4694      	mov	ip, r2
  tp->realprio  = prio;
 8000ade:	66d9      	str	r1, [r3, #108]	; 0x6c
  tp->epending  = (eventmask_t)0;
 8000ae0:	665c      	str	r4, [r3, #100]	; 0x64
 8000ae2:	6a12      	ldr	r2, [r2, #32]
 8000ae4:	486a      	ldr	r0, [pc, #424]	; (8000c90 <main+0x3a0>)
 8000ae6:	3758      	adds	r7, #88	; 0x58
 8000ae8:	659f      	str	r7, [r3, #88]	; 0x58
  tqp->next = (thread_t *)tqp;
 8000aea:	001f      	movs	r7, r3
 8000aec:	4002      	ands	r2, r0
 8000aee:	4660      	mov	r0, ip
 8000af0:	375c      	adds	r7, #92	; 0x5c
  tp->mtxlist   = NULL;
 8000af2:	669c      	str	r4, [r3, #104]	; 0x68
  REG_INSERT(tp);
 8000af4:	641b      	str	r3, [r3, #64]	; 0x40
 8000af6:	645b      	str	r3, [r3, #68]	; 0x44
 8000af8:	65df      	str	r7, [r3, #92]	; 0x5c
  tqp->prev = (thread_t *)tqp;
 8000afa:	661f      	str	r7, [r3, #96]	; 0x60
  currp->wabase = NULL;
 8000afc:	64dc      	str	r4, [r3, #76]	; 0x4c
 8000afe:	6202      	str	r2, [r0, #32]
 8000b00:	b662      	cpsie	i
  __ASM volatile ("cpsid i" : : : "memory");
 8000b02:	b672      	cpsid	i
  tp->wabase = tdp->wbase;
 8000b04:	20ac      	movs	r0, #172	; 0xac
 8000b06:	4a63      	ldr	r2, [pc, #396]	; (8000c94 <main+0x3a4>)
 8000b08:	5012      	str	r2, [r2, r0]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000b0a:	3840      	subs	r0, #64	; 0x40
 8000b0c:	4680      	mov	r8, r0
 8000b0e:	4490      	add	r8, r2
 8000b10:	4647      	mov	r7, r8
 8000b12:	3030      	adds	r0, #48	; 0x30
 8000b14:	5017      	str	r7, [r2, r0]
 8000b16:	4860      	ldr	r0, [pc, #384]	; (8000c98 <main+0x3a8>)
 8000b18:	5054      	str	r4, [r2, r1]
 8000b1a:	67d0      	str	r0, [r2, #124]	; 0x7c
 8000b1c:	485f      	ldr	r0, [pc, #380]	; (8000c9c <main+0x3ac>)
 8000b1e:	310c      	adds	r1, #12
 8000b20:	5050      	str	r0, [r2, r1]
  tp->refs      = (trefs_t)1;
 8000b22:	4650      	mov	r0, sl
  tp->prio      = prio;
 8000b24:	310c      	adds	r1, #12
 8000b26:	5055      	str	r5, [r2, r1]
  tp->realprio  = prio;
 8000b28:	3134      	adds	r1, #52	; 0x34
 8000b2a:	5055      	str	r5, [r2, r1]
  tp->mtxlist   = NULL;
 8000b2c:	3904      	subs	r1, #4
 8000b2e:	5054      	str	r4, [r2, r1]
  tp->state     = CH_STATE_WTSTART;
 8000b30:	35af      	adds	r5, #175	; 0xaf
  tp->epending  = (eventmask_t)0;
 8000b32:	3904      	subs	r1, #4
 8000b34:	5054      	str	r4, [r2, r1]
  tp->state     = CH_STATE_WTSTART;
 8000b36:	5356      	strh	r6, [r2, r5]
  tp->refs      = (trefs_t)1;
 8000b38:	3912      	subs	r1, #18
  tp->name      = name;
 8000b3a:	4e59      	ldr	r6, [pc, #356]	; (8000ca0 <main+0x3b0>)
  tp->refs      = (trefs_t)1;
 8000b3c:	5450      	strb	r0, [r2, r1]
  tp->name      = name;
 8000b3e:	390a      	subs	r1, #10
 8000b40:	5056      	str	r6, [r2, r1]
  REG_INSERT(tp);
 8000b42:	695e      	ldr	r6, [r3, #20]
 8000b44:	3908      	subs	r1, #8
 8000b46:	5053      	str	r3, [r2, r1]
 8000b48:	3104      	adds	r1, #4
 8000b4a:	5056      	str	r6, [r2, r1]
 8000b4c:	0011      	movs	r1, r2
 8000b4e:	3190      	adds	r1, #144	; 0x90
 8000b50:	6131      	str	r1, [r6, #16]
  tlp->next = (thread_t *)tlp;
 8000b52:	0016      	movs	r6, r2
 8000b54:	6159      	str	r1, [r3, #20]
 8000b56:	21b8      	movs	r1, #184	; 0xb8
 8000b58:	36b8      	adds	r6, #184	; 0xb8
 8000b5a:	5056      	str	r6, [r2, r1]
  tqp->next = (thread_t *)tqp;
 8000b5c:	0011      	movs	r1, r2
 8000b5e:	26bc      	movs	r6, #188	; 0xbc
 8000b60:	31bc      	adds	r1, #188	; 0xbc
 8000b62:	5191      	str	r1, [r2, r6]
  tqp->prev = (thread_t *)tqp;
 8000b64:	3604      	adds	r6, #4
 8000b66:	5191      	str	r1, [r2, r6]
  thread_t *otp = currp;
 8000b68:	6999      	ldr	r1, [r3, #24]
  ntp->u.rdymsg = msg;
 8000b6a:	3e0c      	subs	r6, #12
 8000b6c:	5194      	str	r4, [r2, r6]
  if (ntp->prio <= otp->prio) {
 8000b6e:	6888      	ldr	r0, [r1, #8]
 8000b70:	2800      	cmp	r0, #0
 8000b72:	d046      	beq.n	8000c02 <main+0x312>
  tp->state = CH_STATE_READY;
 8000b74:	4649      	mov	r1, r9
 8000b76:	5551      	strb	r1, [r2, r5]
    cp = cp->queue.next;
 8000b78:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000b7a:	6899      	ldr	r1, [r3, #8]
 8000b7c:	2900      	cmp	r1, #0
 8000b7e:	d1fb      	bne.n	8000b78 <main+0x288>
  tp->queue.prev             = cp->queue.prev;
 8000b80:	2094      	movs	r0, #148	; 0x94
  tp->queue.next             = cp;
 8000b82:	3190      	adds	r1, #144	; 0x90
 8000b84:	5053      	str	r3, [r2, r1]
  tp->queue.prev             = cp->queue.prev;
 8000b86:	6859      	ldr	r1, [r3, #4]
 8000b88:	5011      	str	r1, [r2, r0]
  tp->queue.prev->queue.next = tp;
 8000b8a:	4a46      	ldr	r2, [pc, #280]	; (8000ca4 <main+0x3b4>)
 8000b8c:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8000b8e:	605a      	str	r2, [r3, #4]
  __ASM volatile ("cpsie i" : : : "memory");
 8000b90:	b662      	cpsie	i
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8000b92:	2103      	movs	r1, #3
 8000b94:	468c      	mov	ip, r1
      m4 = 15 << ((bit & 7) * 4);
 8000b96:	310c      	adds	r1, #12
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000b98:	2401      	movs	r4, #1
  uint32_t bit     = 0;
 8000b9a:	2200      	movs	r2, #0
 8000b9c:	2040      	movs	r0, #64	; 0x40
    if ((mask & 1) != 0) {
 8000b9e:	2601      	movs	r6, #1
      m4 = 15 << ((bit & 7) * 4);
 8000ba0:	4688      	mov	r8, r1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000ba2:	4b41      	ldr	r3, [pc, #260]	; (8000ca8 <main+0x3b8>)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 8000ba4:	0840      	lsrs	r0, r0, #1
    if (!mask)
 8000ba6:	2a06      	cmp	r2, #6
 8000ba8:	d01e      	beq.n	8000be8 <main+0x2f8>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8000baa:	00a4      	lsls	r4, r4, #2
    bit++;
 8000bac:	3201      	adds	r2, #1
    if ((mask & 1) != 0) {
 8000bae:	4206      	tst	r6, r0
 8000bb0:	d0f8      	beq.n	8000ba4 <main+0x2b4>
      m1 = 1 << bit;
 8000bb2:	0035      	movs	r5, r6
 8000bb4:	4095      	lsls	r5, r2
      m2 = 3 << (bit * 2);
 8000bb6:	4667      	mov	r7, ip
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000bb8:	6859      	ldr	r1, [r3, #4]
    mask >>= 1;
 8000bba:	0840      	lsrs	r0, r0, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000bbc:	43a9      	bics	r1, r5
      m2 = 3 << (bit * 2);
 8000bbe:	0055      	lsls	r5, r2, #1
 8000bc0:	40af      	lsls	r7, r5
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000bc2:	6059      	str	r1, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000bc4:	6899      	ldr	r1, [r3, #8]
      m4 = 15 << ((bit & 7) * 4);
 8000bc6:	0095      	lsls	r5, r2, #2
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000bc8:	43b9      	bics	r1, r7
 8000bca:	6099      	str	r1, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000bcc:	68d9      	ldr	r1, [r3, #12]
 8000bce:	43b9      	bics	r1, r7
 8000bd0:	60d9      	str	r1, [r3, #12]
        port->MODER   = (port->MODER & ~m2) | moder;
 8000bd2:	6819      	ldr	r1, [r3, #0]
 8000bd4:	43b9      	bics	r1, r7
      m4 = 15 << ((bit & 7) * 4);
 8000bd6:	4647      	mov	r7, r8
 8000bd8:	40af      	lsls	r7, r5
        port->MODER   = (port->MODER & ~m2) | moder;
 8000bda:	4321      	orrs	r1, r4
 8000bdc:	6019      	str	r1, [r3, #0]
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000bde:	6a19      	ldr	r1, [r3, #32]
 8000be0:	43b9      	bics	r1, r7
 8000be2:	6219      	str	r1, [r3, #32]
    if (!mask)
 8000be4:	2a06      	cmp	r2, #6
 8000be6:	d1e0      	bne.n	8000baa <main+0x2ba>
  chSysInit();

  palSetPadMode(GPIOB, GPIOB_ARD_D10, PAL_MODE_OUTPUT_PUSHPULL);
  while (true) {

    palTogglePad(GPIOB, GPIOB_ARD_D10);
 8000be8:	2540      	movs	r5, #64	; 0x40
 8000bea:	4c2f      	ldr	r4, [pc, #188]	; (8000ca8 <main+0x3b8>)
 8000bec:	6963      	ldr	r3, [r4, #20]
 8000bee:	406b      	eors	r3, r5
 8000bf0:	6163      	str	r3, [r4, #20]
  __ASM volatile ("cpsid i" : : : "memory");
 8000bf2:	b672      	cpsid	i
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8000bf4:	2196      	movs	r1, #150	; 0x96
 8000bf6:	2008      	movs	r0, #8
 8000bf8:	0049      	lsls	r1, r1, #1
 8000bfa:	f7ff fc69 	bl	80004d0 <chSchGoSleepTimeoutS>
  __ASM volatile ("cpsie i" : : : "memory");
 8000bfe:	b662      	cpsie	i
 8000c00:	e7f4      	b.n	8000bec <main+0x2fc>
  tp->state = CH_STATE_READY;
 8000c02:	4648      	mov	r0, r9
 8000c04:	2420      	movs	r4, #32
 8000c06:	5508      	strb	r0, [r1, r4]
  cp = (thread_t *)&ch.rlist.queue;
 8000c08:	0018      	movs	r0, r3
    cp = cp->queue.next;
 8000c0a:	6800      	ldr	r0, [r0, #0]
  } while (cp->prio > tp->prio);
 8000c0c:	6884      	ldr	r4, [r0, #8]
 8000c0e:	2c00      	cmp	r4, #0
 8000c10:	d1fb      	bne.n	8000c0a <main+0x31a>
  tp->queue.prev             = cp->queue.prev;
 8000c12:	6844      	ldr	r4, [r0, #4]
  tp->queue.next             = cp;
 8000c14:	6008      	str	r0, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 8000c16:	604c      	str	r4, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8000c18:	6021      	str	r1, [r4, #0]
  cp->queue.prev             = tp;
 8000c1a:	6041      	str	r1, [r0, #4]
    currp = ntp;
 8000c1c:	4821      	ldr	r0, [pc, #132]	; (8000ca4 <main+0x3b4>)
    ntp->state = CH_STATE_CURRENT;
 8000c1e:	2401      	movs	r4, #1
    currp = ntp;
 8000c20:	6198      	str	r0, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 8000c22:	23b0      	movs	r3, #176	; 0xb0
 8000c24:	54d4      	strb	r4, [r2, r3]
    chSysSwitch(ntp, otp);
 8000c26:	f7ff fab7 	bl	8000198 <_port_switch>
 8000c2a:	e7b1      	b.n	8000b90 <main+0x2a0>
 8000c2c:	40021000 	.word	0x40021000
 8000c30:	ffa1ffff 	.word	0xffa1ffff
 8000c34:	ffbfffff 	.word	0xffbfffff
 8000c38:	40007000 	.word	0x40007000
 8000c3c:	20000400 	.word	0x20000400
 8000c40:	08001294 	.word	0x08001294
 8000c44:	2000061c 	.word	0x2000061c
 8000c48:	2000062c 	.word	0x2000062c
 8000c4c:	080002c1 	.word	0x080002c1
 8000c50:	40004400 	.word	0x40004400
 8000c54:	02dc6c00 	.word	0x02dc6c00
 8000c58:	40015800 	.word	0x40015800
 8000c5c:	40000400 	.word	0x40000400
 8000c60:	0000bb7f 	.word	0x0000bb7f
 8000c64:	0000ffff 	.word	0x0000ffff
 8000c68:	20000460 	.word	0x20000460
 8000c6c:	20000640 	.word	0x20000640
 8000c70:	200005f8 	.word	0x200005f8
 8000c74:	20002000 	.word	0x20002000
 8000c78:	20000600 	.word	0x20000600
 8000c7c:	08000291 	.word	0x08000291
 8000c80:	200004d4 	.word	0x200004d4
 8000c84:	08000311 	.word	0x08000311
 8000c88:	080011fc 	.word	0x080011fc
 8000c8c:	e000ed00 	.word	0xe000ed00
 8000c90:	ff00ffff 	.word	0xff00ffff
 8000c94:	20000520 	.word	0x20000520
 8000c98:	08000441 	.word	0x08000441
 8000c9c:	080001b9 	.word	0x080001b9
 8000ca0:	080011f4 	.word	0x080011f4
 8000ca4:	200005b0 	.word	0x200005b0
 8000ca8:	48000400 	.word	0x48000400
 8000cac:	00000000 	.word	0x00000000

08000cb0 <NMI_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000cb0:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
 8000cb4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8000cb6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8000cba:	b662      	cpsie	i
}
 8000cbc:	4770      	bx	lr
 8000cbe:	46c0      	nop			; (mov r8, r8)

08000cc0 <chThdExit>:
void chThdExit(msg_t msg) {
 8000cc0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 8000cc2:	b672      	cpsid	i
  thread_t *tp = currp;
 8000cc4:	4b0f      	ldr	r3, [pc, #60]	; (8000d04 <chThdExit+0x44>)
 8000cc6:	699c      	ldr	r4, [r3, #24]
  while (list_notempty(&tp->waiting)) {
 8000cc8:	0025      	movs	r5, r4
  tp->u.exitcode = msg;
 8000cca:	6260      	str	r0, [r4, #36]	; 0x24
  return (bool)(tlp->next != (thread_t *)tlp);
 8000ccc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8000cce:	3528      	adds	r5, #40	; 0x28
 8000cd0:	42a8      	cmp	r0, r5
 8000cd2:	d006      	beq.n	8000ce2 <chThdExit+0x22>
  tlp->next = tp->queue.next;
 8000cd4:	6803      	ldr	r3, [r0, #0]
 8000cd6:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8000cd8:	f7ff fb62 	bl	80003a0 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8000cdc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8000cde:	42a8      	cmp	r0, r5
 8000ce0:	d1f8      	bne.n	8000cd4 <chThdExit+0x14>
  if ((tp->refs == (trefs_t)0) &&
 8000ce2:	2322      	movs	r3, #34	; 0x22
 8000ce4:	5ce3      	ldrb	r3, [r4, r3]
 8000ce6:	2b00      	cmp	r3, #0
 8000ce8:	d107      	bne.n	8000cfa <chThdExit+0x3a>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8000cea:	3321      	adds	r3, #33	; 0x21
  if ((tp->refs == (trefs_t)0) &&
 8000cec:	5ce3      	ldrb	r3, [r4, r3]
 8000cee:	079b      	lsls	r3, r3, #30
 8000cf0:	d103      	bne.n	8000cfa <chThdExit+0x3a>
    REG_REMOVE(tp);
 8000cf2:	6962      	ldr	r2, [r4, #20]
 8000cf4:	6923      	ldr	r3, [r4, #16]
 8000cf6:	6113      	str	r3, [r2, #16]
 8000cf8:	615a      	str	r2, [r3, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 8000cfa:	200f      	movs	r0, #15
 8000cfc:	f7ff fbd0 	bl	80004a0 <chSchGoSleepS>
}
 8000d00:	bd70      	pop	{r4, r5, r6, pc}
 8000d02:	46c0      	nop			; (mov r8, r8)
 8000d04:	20000460 	.word	0x20000460
	...

08000d10 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 8000d10:	4a0d      	ldr	r2, [pc, #52]	; (8000d48 <chSchDoReschedule+0x38>)
void chSchDoReschedule(void) {
 8000d12:	b570      	push	{r4, r5, r6, lr}
  thread_t *tp = tqp->next;
 8000d14:	6810      	ldr	r0, [r2, #0]
  thread_t *otp = currp;
 8000d16:	6991      	ldr	r1, [r2, #24]
  tqp->next             = tp->queue.next;
 8000d18:	6803      	ldr	r3, [r0, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000d1a:	2420      	movs	r4, #32
  tqp->next->queue.prev = (thread_t *)tqp;
 8000d1c:	605a      	str	r2, [r3, #4]
  tqp->next             = tp->queue.next;
 8000d1e:	6013      	str	r3, [r2, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000d20:	6190      	str	r0, [r2, #24]
  currp->state = CH_STATE_CURRENT;
 8000d22:	2201      	movs	r2, #1
  tp->state = CH_STATE_READY;
 8000d24:	2500      	movs	r5, #0
  currp->state = CH_STATE_CURRENT;
 8000d26:	5502      	strb	r2, [r0, r4]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 8000d28:	688a      	ldr	r2, [r1, #8]
  tp->state = CH_STATE_READY;
 8000d2a:	550d      	strb	r5, [r1, r4]
  cp = (thread_t *)&ch.rlist.queue;
 8000d2c:	e000      	b.n	8000d30 <chSchDoReschedule+0x20>
 8000d2e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8000d30:	689c      	ldr	r4, [r3, #8]
 8000d32:	42a2      	cmp	r2, r4
 8000d34:	d3fb      	bcc.n	8000d2e <chSchDoReschedule+0x1e>
  tp->queue.prev             = cp->queue.prev;
 8000d36:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 8000d38:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 8000d3a:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8000d3c:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8000d3e:	6059      	str	r1, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000d40:	f7ff fa2a 	bl	8000198 <_port_switch>
}
 8000d44:	bd70      	pop	{r4, r5, r6, pc}
 8000d46:	46c0      	nop			; (mov r8, r8)
 8000d48:	20000460 	.word	0x20000460
 8000d4c:	00000000 	.word	0x00000000

08000d50 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 8000d50:	23bc      	movs	r3, #188	; 0xbc
 8000d52:	4a4d      	ldr	r2, [pc, #308]	; (8000e88 <__early_init+0x138>)
 8000d54:	03db      	lsls	r3, r3, #15
 8000d56:	6a91      	ldr	r1, [r2, #40]	; 0x28
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8000d58:	b570      	push	{r4, r5, r6, lr}
  rccResetAHB(STM32_GPIO_EN_MASK);
 8000d5a:	4319      	orrs	r1, r3
 8000d5c:	6291      	str	r1, [r2, #40]	; 0x28
 8000d5e:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8000d60:	484a      	ldr	r0, [pc, #296]	; (8000e8c <__early_init+0x13c>)
  gpiop->OSPEEDR = config->ospeedr;
 8000d62:	2401      	movs	r4, #1
  rccResetAHB(STM32_GPIO_EN_MASK);
 8000d64:	4001      	ands	r1, r0
 8000d66:	6291      	str	r1, [r2, #40]	; 0x28
 8000d68:	6a91      	ldr	r1, [r2, #40]	; 0x28
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 8000d6a:	6951      	ldr	r1, [r2, #20]
  gpiop->OSPEEDR = config->ospeedr;
 8000d6c:	4848      	ldr	r0, [pc, #288]	; (8000e90 <__early_init+0x140>)
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 8000d6e:	430b      	orrs	r3, r1
 8000d70:	6153      	str	r3, [r2, #20]
  gpiop->OTYPER  = config->otyper;
 8000d72:	2190      	movs	r1, #144	; 0x90
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 8000d74:	6953      	ldr	r3, [r2, #20]
  gpiop->OTYPER  = config->otyper;
 8000d76:	2300      	movs	r3, #0
 8000d78:	05c9      	lsls	r1, r1, #23
 8000d7a:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000d7c:	6088      	str	r0, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8000d7e:	4845      	ldr	r0, [pc, #276]	; (8000e94 <__early_init+0x144>)
  gpiop->MODER   = config->moder;
 8000d80:	2680      	movs	r6, #128	; 0x80
  gpiop->PUPDR   = config->pupdr;
 8000d82:	60c8      	str	r0, [r1, #12]
  gpiop->ODR     = config->odr;
 8000d84:	4844      	ldr	r0, [pc, #272]	; (8000e98 <__early_init+0x148>)
  gpiop->PUPDR   = config->pupdr;
 8000d86:	4d45      	ldr	r5, [pc, #276]	; (8000e9c <__early_init+0x14c>)
  gpiop->ODR     = config->odr;
 8000d88:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8000d8a:	2088      	movs	r0, #136	; 0x88
 8000d8c:	0140      	lsls	r0, r0, #5
 8000d8e:	6208      	str	r0, [r1, #32]
  gpiop->MODER   = config->moder;
 8000d90:	4843      	ldr	r0, [pc, #268]	; (8000ea0 <__early_init+0x150>)
  gpiop->AFRH    = config->afrh;
 8000d92:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000d94:	6008      	str	r0, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8000d96:	4943      	ldr	r1, [pc, #268]	; (8000ea4 <__early_init+0x154>)
  gpiop->ODR     = config->odr;
 8000d98:	4843      	ldr	r0, [pc, #268]	; (8000ea8 <__early_init+0x158>)
  gpiop->OSPEEDR = config->ospeedr;
 8000d9a:	4264      	negs	r4, r4
  gpiop->OTYPER  = config->otyper;
 8000d9c:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000d9e:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8000da0:	60cd      	str	r5, [r1, #12]
  gpiop->ODR     = config->odr;
 8000da2:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8000da4:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8000da6:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000da8:	600e      	str	r6, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8000daa:	4940      	ldr	r1, [pc, #256]	; (8000eac <__early_init+0x15c>)
  gpiop->PUPDR   = config->pupdr;
 8000dac:	4e40      	ldr	r6, [pc, #256]	; (8000eb0 <__early_init+0x160>)
  gpiop->OTYPER  = config->otyper;
 8000dae:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000db0:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8000db2:	60ce      	str	r6, [r1, #12]
  gpiop->ODR     = config->odr;
 8000db4:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8000db6:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8000db8:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000dba:	600b      	str	r3, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8000dbc:	493d      	ldr	r1, [pc, #244]	; (8000eb4 <__early_init+0x164>)
 8000dbe:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000dc0:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8000dc2:	60cd      	str	r5, [r1, #12]
 8000dc4:	4c3c      	ldr	r4, [pc, #240]	; (8000eb8 <__early_init+0x168>)
  gpiop->ODR     = config->odr;
 8000dc6:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8000dc8:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8000dca:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000dcc:	600b      	str	r3, [r1, #0]
  gpiop->OTYPER  = config->otyper;
 8000dce:	493b      	ldr	r1, [pc, #236]	; (8000ebc <__early_init+0x16c>)
 8000dd0:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000dd2:	608b      	str	r3, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8000dd4:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 8000dd6:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8000dd8:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8000dda:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000ddc:	600b      	str	r3, [r1, #0]
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000dde:	2101      	movs	r1, #1
 8000de0:	6813      	ldr	r3, [r2, #0]
 8000de2:	430b      	orrs	r3, r1
 8000de4:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000de6:	2302      	movs	r3, #2
 8000de8:	6811      	ldr	r1, [r2, #0]
 8000dea:	420b      	tst	r3, r1
 8000dec:	d0fc      	beq.n	8000de8 <__early_init+0x98>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8000dee:	2103      	movs	r1, #3
 8000df0:	6853      	ldr	r3, [r2, #4]
 8000df2:	438b      	bics	r3, r1
 8000df4:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000df6:	220c      	movs	r2, #12
 8000df8:	4b23      	ldr	r3, [pc, #140]	; (8000e88 <__early_init+0x138>)
 8000dfa:	0010      	movs	r0, r2
 8000dfc:	6859      	ldr	r1, [r3, #4]
 8000dfe:	4008      	ands	r0, r1
 8000e00:	420a      	tst	r2, r1
 8000e02:	d1fa      	bne.n	8000dfa <__early_init+0xaa>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000e04:	22f9      	movs	r2, #249	; 0xf9
 8000e06:	6819      	ldr	r1, [r3, #0]
 8000e08:	400a      	ands	r2, r1
 8000e0a:	601a      	str	r2, [r3, #0]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8000e0c:	22a0      	movs	r2, #160	; 0xa0
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000e0e:	6058      	str	r0, [r3, #4]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8000e10:	6819      	ldr	r1, [r3, #0]
 8000e12:	02d2      	lsls	r2, r2, #11
 8000e14:	430a      	orrs	r2, r1
 8000e16:	601a      	str	r2, [r3, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8000e18:	2280      	movs	r2, #128	; 0x80
 8000e1a:	4b1b      	ldr	r3, [pc, #108]	; (8000e88 <__early_init+0x138>)
 8000e1c:	0292      	lsls	r2, r2, #10
 8000e1e:	6819      	ldr	r1, [r3, #0]
 8000e20:	4211      	tst	r1, r2
 8000e22:	d0fc      	beq.n	8000e1e <__early_init+0xce>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000e24:	2101      	movs	r1, #1
 8000e26:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000e28:	430a      	orrs	r2, r1
 8000e2a:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000e2c:	2202      	movs	r2, #2
 8000e2e:	4b16      	ldr	r3, [pc, #88]	; (8000e88 <__early_init+0x138>)
 8000e30:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8000e32:	420a      	tst	r2, r1
 8000e34:	d0fc      	beq.n	8000e30 <__early_init+0xe0>
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8000e36:	21a0      	movs	r1, #160	; 0xa0
  RCC->CFGR2 = STM32_PREDIV;
 8000e38:	2200      	movs	r2, #0
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8000e3a:	0389      	lsls	r1, r1, #14
  RCC->CFGR2 = STM32_PREDIV;
 8000e3c:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8000e3e:	6059      	str	r1, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE |
               ((STM32_PREDIV & STM32_PLLXTPRE_MASK) << STM32_PLLXTPRE_OFFSET);
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8000e40:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000e42:	2280      	movs	r2, #128	; 0x80
 8000e44:	6819      	ldr	r1, [r3, #0]
 8000e46:	0452      	lsls	r2, r2, #17
 8000e48:	430a      	orrs	r2, r1
 8000e4a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000e4c:	2380      	movs	r3, #128	; 0x80
 8000e4e:	4a0e      	ldr	r2, [pc, #56]	; (8000e88 <__early_init+0x138>)
 8000e50:	049b      	lsls	r3, r3, #18
 8000e52:	6811      	ldr	r1, [r2, #0]
 8000e54:	4219      	tst	r1, r3
 8000e56:	d0fc      	beq.n	8000e52 <__early_init+0x102>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000e58:	2211      	movs	r2, #17
 8000e5a:	4b19      	ldr	r3, [pc, #100]	; (8000ec0 <__early_init+0x170>)
 8000e5c:	601a      	str	r2, [r3, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8000e5e:	3a10      	subs	r2, #16
 8000e60:	6819      	ldr	r1, [r3, #0]
 8000e62:	420a      	tst	r2, r1
 8000e64:	d0fc      	beq.n	8000e60 <__early_init+0x110>
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8000e66:	2102      	movs	r1, #2
 8000e68:	4b07      	ldr	r3, [pc, #28]	; (8000e88 <__early_init+0x138>)
 8000e6a:	685a      	ldr	r2, [r3, #4]
 8000e6c:	430a      	orrs	r2, r1
 8000e6e:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000e70:	310a      	adds	r1, #10
 8000e72:	685a      	ldr	r2, [r3, #4]
 8000e74:	400a      	ands	r2, r1
 8000e76:	2a08      	cmp	r2, #8
 8000e78:	d1fb      	bne.n	8000e72 <__early_init+0x122>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8000e7a:	2101      	movs	r1, #1
 8000e7c:	699a      	ldr	r2, [r3, #24]
 8000e7e:	430a      	orrs	r2, r1
 8000e80:	619a      	str	r2, [r3, #24]
 8000e82:	699b      	ldr	r3, [r3, #24]

  stm32_gpio_init();
  stm32_clock_init();
}
 8000e84:	bd70      	pop	{r4, r5, r6, pc}
 8000e86:	46c0      	nop			; (mov r8, r8)
 8000e88:	40021000 	.word	0x40021000
 8000e8c:	ffa1ffff 	.word	0xffa1ffff
 8000e90:	fffff75f 	.word	0xfffff75f
 8000e94:	65555105 	.word	0x65555105
 8000e98:	0000ffdf 	.word	0x0000ffdf
 8000e9c:	55555555 	.word	0x55555555
 8000ea0:	280004a0 	.word	0x280004a0
 8000ea4:	48000400 	.word	0x48000400
 8000ea8:	0000ffff 	.word	0x0000ffff
 8000eac:	48000800 	.word	0x48000800
 8000eb0:	01555555 	.word	0x01555555
 8000eb4:	48000c00 	.word	0x48000c00
 8000eb8:	55555550 	.word	0x55555550
 8000ebc:	48001400 	.word	0x48001400
 8000ec0:	40022000 	.word	0x40022000
	...

08000ed0 <Vector80>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000ed0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8000ed2:	4d2e      	ldr	r5, [pc, #184]	; (8000f8c <Vector80+0xbc>)
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000ed4:	46ce      	mov	lr, r9
  sr  = timp->SR;
 8000ed6:	692b      	ldr	r3, [r5, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8000ed8:	68ea      	ldr	r2, [r5, #12]
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000eda:	4647      	mov	r7, r8
 8000edc:	401a      	ands	r2, r3
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8000ede:	23ff      	movs	r3, #255	; 0xff
 8000ee0:	4013      	ands	r3, r2
  timp->SR = ~sr;
 8000ee2:	43db      	mvns	r3, r3
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000ee4:	b580      	push	{r7, lr}
  OSAL_IRQ_PROLOGUE();
 8000ee6:	46f0      	mov	r8, lr
  timp->SR = ~sr;
 8000ee8:	612b      	str	r3, [r5, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8000eea:	0793      	lsls	r3, r2, #30
 8000eec:	d408      	bmi.n	8000f00 <Vector80+0x30>
  if (lr != 0xFFFFFFF1U) {
 8000eee:	4643      	mov	r3, r8
 8000ef0:	330f      	adds	r3, #15
 8000ef2:	d001      	beq.n	8000ef8 <Vector80+0x28>
 8000ef4:	f7ff f9ec 	bl	80002d0 <_port_irq_epilogue.part.0>
}
 8000ef8:	bc0c      	pop	{r2, r3}
 8000efa:	4690      	mov	r8, r2
 8000efc:	4699      	mov	r9, r3
 8000efe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000f00:	b672      	cpsid	i
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8000f02:	4e23      	ldr	r6, [pc, #140]	; (8000f90 <Vector80+0xc0>)
  return (systime_t)STM32_ST_TIM->CNT;
 8000f04:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000f06:	69f3      	ldr	r3, [r6, #28]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8000f08:	8d31      	ldrh	r1, [r6, #40]	; 0x28
 8000f0a:	b292      	uxth	r2, r2
  return (sysinterval_t)((systime_t)(end - start));
 8000f0c:	1a54      	subs	r4, r2, r1

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8000f0e:	6898      	ldr	r0, [r3, #8]
 8000f10:	b2a4      	uxth	r4, r4
 8000f12:	42a0      	cmp	r0, r4
 8000f14:	d821      	bhi.n	8000f5a <Vector80+0x8a>

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000f16:	0037      	movs	r7, r6
 8000f18:	371c      	adds	r7, #28
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 8000f1a:	2200      	movs	r2, #0
 8000f1c:	4691      	mov	r9, r2
 8000f1e:	e008      	b.n	8000f32 <Vector80+0x62>
  __ASM volatile ("cpsie i" : : : "memory");
 8000f20:	b662      	cpsie	i
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 8000f22:	6918      	ldr	r0, [r3, #16]
 8000f24:	4788      	blx	r1
  __ASM volatile ("cpsid i" : : : "memory");
 8000f26:	b672      	cpsid	i
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8000f28:	69f3      	ldr	r3, [r6, #28]
    }
    while (vtp->delta <= nowdelta);
 8000f2a:	6898      	ldr	r0, [r3, #8]
 8000f2c:	4284      	cmp	r4, r0
 8000f2e:	d30d      	bcc.n	8000f4c <Vector80+0x7c>
 8000f30:	8d31      	ldrh	r1, [r6, #40]	; 0x28
      ch.vtlist.lasttime += vtp->delta;
 8000f32:	1809      	adds	r1, r1, r0
      nowdelta -= vtp->delta;
 8000f34:	1a24      	subs	r4, r4, r0
      vtp->func = NULL;
 8000f36:	4648      	mov	r0, r9
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000f38:	681a      	ldr	r2, [r3, #0]
      ch.vtlist.lasttime += vtp->delta;
 8000f3a:	8531      	strh	r1, [r6, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000f3c:	6057      	str	r7, [r2, #4]
      fn = vtp->func;
 8000f3e:	68d9      	ldr	r1, [r3, #12]
      ch.vtlist.next = vtp->next;
 8000f40:	61f2      	str	r2, [r6, #28]
      vtp->func = NULL;
 8000f42:	60d8      	str	r0, [r3, #12]
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000f44:	42ba      	cmp	r2, r7
 8000f46:	d1eb      	bne.n	8000f20 <Vector80+0x50>
  STM32_ST_TIM->DIER = 0U;
 8000f48:	60e8      	str	r0, [r5, #12]
 8000f4a:	e7e9      	b.n	8000f20 <Vector80+0x50>
  return (systime_t)STM32_ST_TIM->CNT;
 8000f4c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8000f4e:	8d31      	ldrh	r1, [r6, #40]	; 0x28
 8000f50:	b292      	uxth	r2, r2
 8000f52:	1a54      	subs	r4, r2, r1
 8000f54:	b2a4      	uxth	r4, r4
    if (nowdelta < vtp->delta) {
 8000f56:	4284      	cmp	r4, r0
 8000f58:	d2df      	bcs.n	8000f1a <Vector80+0x4a>
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000f5a:	0031      	movs	r1, r6
 8000f5c:	311c      	adds	r1, #28
 8000f5e:	428b      	cmp	r3, r1
 8000f60:	d00d      	beq.n	8000f7e <Vector80+0xae>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 8000f62:	6899      	ldr	r1, [r3, #8]
  ch.vtlist.lasttime += nowdelta;
 8000f64:	8532      	strh	r2, [r6, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8000f66:	1b0c      	subs	r4, r1, r4
 8000f68:	609c      	str	r4, [r3, #8]
  return systime + (systime_t)interval;
 8000f6a:	2380      	movs	r3, #128	; 0x80
 8000f6c:	025b      	lsls	r3, r3, #9
 8000f6e:	429c      	cmp	r4, r3
 8000f70:	d209      	bcs.n	8000f86 <Vector80+0xb6>
 8000f72:	2c02      	cmp	r4, #2
 8000f74:	d305      	bcc.n	8000f82 <Vector80+0xb2>
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000f76:	4b05      	ldr	r3, [pc, #20]	; (8000f8c <Vector80+0xbc>)
 8000f78:	1912      	adds	r2, r2, r4
 8000f7a:	b292      	uxth	r2, r2
 8000f7c:	635a      	str	r2, [r3, #52]	; 0x34
  __ASM volatile ("cpsie i" : : : "memory");
 8000f7e:	b662      	cpsie	i
 8000f80:	e7b5      	b.n	8000eee <Vector80+0x1e>
 8000f82:	2402      	movs	r4, #2
 8000f84:	e7f7      	b.n	8000f76 <Vector80+0xa6>
 8000f86:	4c03      	ldr	r4, [pc, #12]	; (8000f94 <Vector80+0xc4>)
 8000f88:	e7f5      	b.n	8000f76 <Vector80+0xa6>
 8000f8a:	46c0      	nop			; (mov r8, r8)
 8000f8c:	40000400 	.word	0x40000400
 8000f90:	20000460 	.word	0x20000460
 8000f94:	0000ffff 	.word	0x0000ffff
	...

08000fa0 <VectorB0>:
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000fa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000fa2:	464e      	mov	r6, r9
 8000fa4:	46de      	mov	lr, fp
 8000fa6:	4657      	mov	r7, sl
 8000fa8:	4645      	mov	r5, r8
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000faa:	4c5f      	ldr	r4, [pc, #380]	; (8001128 <VectorB0+0x188>)
 8000fac:	b5e0      	push	{r5, r6, r7, lr}
 8000fae:	6d66      	ldr	r6, [r4, #84]	; 0x54
  OSAL_IRQ_PROLOGUE();
 8000fb0:	46f1      	mov	r9, lr
  uint32_t cr1 = u->CR1;
 8000fb2:	6837      	ldr	r7, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000fb4:	69f5      	ldr	r5, [r6, #28]
  u->ICR = isr;
 8000fb6:	6235      	str	r5, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000fb8:	072b      	lsls	r3, r5, #28
 8000fba:	d000      	beq.n	8000fbe <VectorB0+0x1e>
 8000fbc:	e092      	b.n	80010e4 <VectorB0+0x144>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 8000fbe:	06ab      	lsls	r3, r5, #26
 8000fc0:	d53e      	bpl.n	8001040 <VectorB0+0xa0>
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8000fc2:	235c      	movs	r3, #92	; 0x5c
 8000fc4:	469a      	mov	sl, r3
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000fc6:	3b50      	subs	r3, #80	; 0x50
 8000fc8:	4698      	mov	r8, r3
 8000fca:	44a0      	add	r8, r4
 8000fcc:	e01e      	b.n	800100c <VectorB0+0x6c>
  if (!iqIsFullI(iqp)) {
 8000fce:	6a23      	ldr	r3, [r4, #32]
 8000fd0:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000fd2:	4293      	cmp	r3, r2
 8000fd4:	d029      	beq.n	800102a <VectorB0+0x8a>
    iqp->q_counter++;
 8000fd6:	6962      	ldr	r2, [r4, #20]
 8000fd8:	3201      	adds	r2, #1
 8000fda:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 8000fdc:	1c5a      	adds	r2, r3, #1
 8000fde:	6222      	str	r2, [r4, #32]
 8000fe0:	701d      	strb	r5, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000fe2:	6a23      	ldr	r3, [r4, #32]
 8000fe4:	69e2      	ldr	r2, [r4, #28]
 8000fe6:	4293      	cmp	r3, r2
 8000fe8:	d301      	bcc.n	8000fee <VectorB0+0x4e>
      iqp->q_wrptr = iqp->q_buffer;
 8000fea:	69a3      	ldr	r3, [r4, #24]
 8000fec:	6223      	str	r3, [r4, #32]
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000fee:	68e0      	ldr	r0, [r4, #12]
 8000ff0:	4540      	cmp	r0, r8
 8000ff2:	d007      	beq.n	8001004 <VectorB0+0x64>
  tqp->next->queue.prev = (thread_t *)tqp;
 8000ff4:	4642      	mov	r2, r8
  tqp->next             = tp->queue.next;
 8000ff6:	6803      	ldr	r3, [r0, #0]
 8000ff8:	60e3      	str	r3, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000ffa:	605a      	str	r2, [r3, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000ffc:	2300      	movs	r3, #0
 8000ffe:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001000:	f7ff f9ce 	bl	80003a0 <chSchReadyI>
 8001004:	b662      	cpsie	i
    osalSysUnlockFromISR();

    isr = u->ISR;
 8001006:	69f5      	ldr	r5, [r6, #28]
  while (isr & USART_ISR_RXNE) {
 8001008:	06ab      	lsls	r3, r5, #26
 800100a:	d519      	bpl.n	8001040 <VectorB0+0xa0>
  __ASM volatile ("cpsid i" : : : "memory");
 800100c:	b672      	cpsid	i
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 800100e:	4653      	mov	r3, sl
 8001010:	8cb5      	ldrh	r5, [r6, #36]	; 0x24
 8001012:	5ce3      	ldrb	r3, [r4, r3]
 8001014:	401d      	ands	r5, r3
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001016:	6963      	ldr	r3, [r4, #20]
 8001018:	2b00      	cmp	r3, #0
 800101a:	d1d8      	bne.n	8000fce <VectorB0+0x2e>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800101c:	2004      	movs	r0, #4
 800101e:	f7ff f9d7 	bl	80003d0 <chEvtBroadcastFlagsI.constprop.0>
  if (!iqIsFullI(iqp)) {
 8001022:	6a23      	ldr	r3, [r4, #32]
 8001024:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001026:	4293      	cmp	r3, r2
 8001028:	d1d5      	bne.n	8000fd6 <VectorB0+0x36>
 800102a:	6962      	ldr	r2, [r4, #20]
 800102c:	2a00      	cmp	r2, #0
 800102e:	d0d2      	beq.n	8000fd6 <VectorB0+0x36>
 8001030:	2080      	movs	r0, #128	; 0x80
 8001032:	00c0      	lsls	r0, r0, #3
 8001034:	f7ff f9cc 	bl	80003d0 <chEvtBroadcastFlagsI.constprop.0>
  __ASM volatile ("cpsie i" : : : "memory");
 8001038:	b662      	cpsie	i
    isr = u->ISR;
 800103a:	69f5      	ldr	r5, [r6, #28]
  while (isr & USART_ISR_RXNE) {
 800103c:	06ab      	lsls	r3, r5, #26
 800103e:	d4e5      	bmi.n	800100c <VectorB0+0x6c>
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
 8001040:	2380      	movs	r3, #128	; 0x80
 8001042:	423b      	tst	r3, r7
 8001044:	d036      	beq.n	80010b4 <VectorB0+0x114>
    while (isr & USART_ISR_TXE) {
 8001046:	422b      	tst	r3, r5
 8001048:	d034      	beq.n	80010b4 <VectorB0+0x114>
 800104a:	2330      	movs	r3, #48	; 0x30
 800104c:	4698      	mov	r8, r3
  tp->u.rdymsg = msg;
 800104e:	2300      	movs	r3, #0
 8001050:	469b      	mov	fp, r3
 8001052:	3380      	adds	r3, #128	; 0x80
 8001054:	469a      	mov	sl, r3
 8001056:	44a0      	add	r8, r4
 8001058:	e01c      	b.n	8001094 <VectorB0+0xf4>
    oqp->q_counter++;
 800105a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800105c:	3201      	adds	r2, #1
 800105e:	63a2      	str	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 8001060:	1c5a      	adds	r2, r3, #1
 8001062:	64a2      	str	r2, [r4, #72]	; 0x48
 8001064:	781d      	ldrb	r5, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8001066:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001068:	429a      	cmp	r2, r3
 800106a:	d301      	bcc.n	8001070 <VectorB0+0xd0>
      oqp->q_rdptr = oqp->q_buffer;
 800106c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800106e:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(tqp->next != (const thread_t *)tqp);
 8001070:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001072:	4540      	cmp	r0, r8
 8001074:	d007      	beq.n	8001086 <VectorB0+0xe6>
  tqp->next->queue.prev = (thread_t *)tqp;
 8001076:	4642      	mov	r2, r8
  tqp->next             = tp->queue.next;
 8001078:	6803      	ldr	r3, [r0, #0]
 800107a:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->next->queue.prev = (thread_t *)tqp;
 800107c:	605a      	str	r2, [r3, #4]
 800107e:	465b      	mov	r3, fp
 8001080:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8001082:	f7ff f98d 	bl	80003a0 <chSchReadyI>
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
        osalSysUnlockFromISR();
        break;
      }
      u->TDR = b;
 8001086:	b2ad      	uxth	r5, r5
 8001088:	8535      	strh	r5, [r6, #40]	; 0x28
 800108a:	b662      	cpsie	i
    while (isr & USART_ISR_TXE) {
 800108c:	4653      	mov	r3, sl
      osalSysUnlockFromISR();

      isr = u->ISR;
 800108e:	69f5      	ldr	r5, [r6, #28]
    while (isr & USART_ISR_TXE) {
 8001090:	422b      	tst	r3, r5
 8001092:	d00f      	beq.n	80010b4 <VectorB0+0x114>
  __ASM volatile ("cpsid i" : : : "memory");
 8001094:	b672      	cpsid	i
  if (!oqIsEmptyI(oqp)) {
 8001096:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001098:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800109a:	429a      	cmp	r2, r3
 800109c:	d1dd      	bne.n	800105a <VectorB0+0xba>
 800109e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80010a0:	2a00      	cmp	r2, #0
 80010a2:	d0da      	beq.n	800105a <VectorB0+0xba>
 80010a4:	2008      	movs	r0, #8
 80010a6:	f7ff f993 	bl	80003d0 <chEvtBroadcastFlagsI.constprop.0>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
 80010aa:	2380      	movs	r3, #128	; 0x80
 80010ac:	003a      	movs	r2, r7
 80010ae:	439a      	bics	r2, r3
 80010b0:	6032      	str	r2, [r6, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 80010b2:	b662      	cpsie	i
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 80010b4:	2340      	movs	r3, #64	; 0x40
 80010b6:	4698      	mov	r8, r3
 80010b8:	423b      	tst	r3, r7
 80010ba:	d10a      	bne.n	80010d2 <VectorB0+0x132>
 80010bc:	464b      	mov	r3, r9
 80010be:	330f      	adds	r3, #15
 80010c0:	d001      	beq.n	80010c6 <VectorB0+0x126>
 80010c2:	f7ff f905 	bl	80002d0 <_port_irq_epilogue.part.0>
}
 80010c6:	bc3c      	pop	{r2, r3, r4, r5}
 80010c8:	4690      	mov	r8, r2
 80010ca:	4699      	mov	r9, r3
 80010cc:	46a2      	mov	sl, r4
 80010ce:	46ab      	mov	fp, r5
 80010d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80010d2:	422b      	tst	r3, r5
 80010d4:	d0f2      	beq.n	80010bc <VectorB0+0x11c>
  __ASM volatile ("cpsid i" : : : "memory");
 80010d6:	b672      	cpsid	i
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
 80010d8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80010da:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80010dc:	4293      	cmp	r3, r2
 80010de:	d019      	beq.n	8001114 <VectorB0+0x174>
  __ASM volatile ("cpsie i" : : : "memory");
 80010e0:	b662      	cpsie	i
 80010e2:	e7eb      	b.n	80010bc <VectorB0+0x11c>
  if (isr & USART_ISR_ORE)
 80010e4:	2308      	movs	r3, #8
 80010e6:	0018      	movs	r0, r3
 80010e8:	4028      	ands	r0, r5
 80010ea:	422b      	tst	r3, r5
 80010ec:	d000      	beq.n	80010f0 <VectorB0+0x150>
    sts |= SD_OVERRUN_ERROR;
 80010ee:	2080      	movs	r0, #128	; 0x80
  if (isr & USART_ISR_PE)
 80010f0:	07eb      	lsls	r3, r5, #31
 80010f2:	d501      	bpl.n	80010f8 <VectorB0+0x158>
    sts |= SD_PARITY_ERROR;
 80010f4:	2320      	movs	r3, #32
 80010f6:	4318      	orrs	r0, r3
  if (isr & USART_ISR_FE)
 80010f8:	07ab      	lsls	r3, r5, #30
 80010fa:	d501      	bpl.n	8001100 <VectorB0+0x160>
    sts |= SD_FRAMING_ERROR;
 80010fc:	2340      	movs	r3, #64	; 0x40
 80010fe:	4318      	orrs	r0, r3
  if (isr & USART_ISR_NE)
 8001100:	076b      	lsls	r3, r5, #29
 8001102:	d502      	bpl.n	800110a <VectorB0+0x16a>
    sts |= SD_NOISE_ERROR;
 8001104:	2380      	movs	r3, #128	; 0x80
 8001106:	005b      	lsls	r3, r3, #1
 8001108:	4318      	orrs	r0, r3
  __ASM volatile ("cpsid i" : : : "memory");
 800110a:	b672      	cpsid	i
 800110c:	f7ff f960 	bl	80003d0 <chEvtBroadcastFlagsI.constprop.0>
  __ASM volatile ("cpsie i" : : : "memory");
 8001110:	b662      	cpsie	i
 8001112:	e754      	b.n	8000fbe <VectorB0+0x1e>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8001114:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001116:	2b00      	cmp	r3, #0
 8001118:	d0e2      	beq.n	80010e0 <VectorB0+0x140>
 800111a:	2010      	movs	r0, #16
 800111c:	f7ff f958 	bl	80003d0 <chEvtBroadcastFlagsI.constprop.0>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001120:	4643      	mov	r3, r8
 8001122:	439f      	bics	r7, r3
 8001124:	6037      	str	r7, [r6, #0]
 8001126:	e7db      	b.n	80010e0 <VectorB0+0x140>
 8001128:	20000400 	.word	0x20000400
 800112c:	00000000 	.word	0x00000000

08001130 <VectorAC>:
 8001130:	4673      	mov	r3, lr
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001132:	b510      	push	{r4, lr}
 8001134:	330f      	adds	r3, #15
 8001136:	d001      	beq.n	800113c <VectorAC+0xc>
 8001138:	f7ff f8ca 	bl	80002d0 <_port_irq_epilogue.part.0>
}
 800113c:	bd10      	pop	{r4, pc}
 800113e:	46c0      	nop			; (mov r8, r8)

08001140 <VectorB4>:
 8001140:	b510      	push	{r4, lr}
 8001142:	f7ff fff5 	bl	8001130 <VectorAC>
 8001146:	bd10      	pop	{r4, pc}
	...

08001150 <__init_ram_areas>:
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001150:	2280      	movs	r2, #128	; 0x80
 8001152:	4694      	mov	ip, r2
void __init_ram_areas(void) {
 8001154:	b5f0      	push	{r4, r5, r6, r7, lr}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001156:	2500      	movs	r5, #0
  const ram_init_area_t *rap = ram_areas;
 8001158:	4e10      	ldr	r6, [pc, #64]	; (800119c <__init_ram_areas+0x4c>)
void __init_ram_areas(void) {
 800115a:	4c11      	ldr	r4, [pc, #68]	; (80011a0 <__init_ram_areas+0x50>)
 800115c:	4911      	ldr	r1, [pc, #68]	; (80011a4 <__init_ram_areas+0x54>)
 800115e:	4b12      	ldr	r3, [pc, #72]	; (80011a8 <__init_ram_areas+0x58>)
 8001160:	4812      	ldr	r0, [pc, #72]	; (80011ac <__init_ram_areas+0x5c>)
 8001162:	44b4      	add	ip, r6
    while (p < rap->clear_area) {
 8001164:	4299      	cmp	r1, r3
 8001166:	d90d      	bls.n	8001184 <__init_ram_areas+0x34>
 8001168:	001a      	movs	r2, r3
      *p = *tp;
 800116a:	c880      	ldmia	r0!, {r7}
 800116c:	c280      	stmia	r2!, {r7}
    while (p < rap->clear_area) {
 800116e:	4291      	cmp	r1, r2
 8001170:	d8fb      	bhi.n	800116a <__init_ram_areas+0x1a>
 8001172:	3901      	subs	r1, #1
 8001174:	1ac9      	subs	r1, r1, r3
 8001176:	0889      	lsrs	r1, r1, #2
 8001178:	3101      	adds	r1, #1
 800117a:	0089      	lsls	r1, r1, #2
 800117c:	185b      	adds	r3, r3, r1
    while (p < rap->no_init_area) {
 800117e:	429c      	cmp	r4, r3
 8001180:	d902      	bls.n	8001188 <__init_ram_areas+0x38>
      *p = 0;
 8001182:	c320      	stmia	r3!, {r5}
    while (p < rap->no_init_area) {
 8001184:	429c      	cmp	r4, r3
 8001186:	d8fc      	bhi.n	8001182 <__init_ram_areas+0x32>
      p++;
    }
    rap++;
 8001188:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800118a:	4566      	cmp	r6, ip
 800118c:	d004      	beq.n	8001198 <__init_ram_areas+0x48>
 800118e:	6830      	ldr	r0, [r6, #0]
 8001190:	6873      	ldr	r3, [r6, #4]
 8001192:	68b1      	ldr	r1, [r6, #8]
 8001194:	68f4      	ldr	r4, [r6, #12]
 8001196:	e7e5      	b.n	8001164 <__init_ram_areas+0x14>
#endif
}
 8001198:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800119a:	46c0      	nop			; (mov r8, r8)
 800119c:	08001214 	.word	0x08001214
 80011a0:	2000063c 	.word	0x2000063c
 80011a4:	2000063c 	.word	0x2000063c
 80011a8:	2000063c 	.word	0x2000063c
 80011ac:	080012bc 	.word	0x080012bc

080011b0 <__default_exit>:
  while (true) {
 80011b0:	e7fe      	b.n	80011b0 <__default_exit>
 80011b2:	46c0      	nop			; (mov r8, r8)
	...

080011c0 <__late_init>:
 80011c0:	4770      	bx	lr
 80011c2:	46c0      	nop			; (mov r8, r8)
	...

080011d0 <__core_init>:
}
 80011d0:	4770      	bx	lr
 80011d2:	46c0      	nop			; (mov r8, r8)
